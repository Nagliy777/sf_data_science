Вы наверняка замечали, что если поставить два зеркала друг напротив друга, отражения в них начнутся повторяться 
и всё больше и больше уходить вдаль. При этом получается так, что в зеркале появляется отражение его самого, которое всё продолжает 
появляться в уменьшенной копии. Это явление, когда какой-то объект содержит в себе самого себя, называется рекурсией.

Пример:
def sum_lst(lst):
    # Выводим текущее значение lst
    print(lst)
    # Задаём условие выхода из рекурсии
    if len(lst) == 0:return 0
    # Во всех других случаях возвращаем
    # сумму первого элемента списка 
    # и результат суммирования оставшихся
    return lst[0] + sum_lst(lst[1:])
 
my_lst = [10, 21, 24, 12]
print(sum_lst(my_lst))

#Будет выведено
#[10, 21, 24, 12]
#[21, 24, 12]
#[24, 12]
#[12]
#[]
#Result 67

Стэк вызова функций.

Хранилище, в которое «откладываются» невыполненные функции называется стэк вызова функций.
(call stack) в стэке действует правило LIFO (last in — first out) — «первый вошёл — последний вышел».
Когда Python при выполнении одной функции встречает шаг, на котором требуется выполнить другую функцию, 
он кладёт начальную функцию в стэк, пока выполняет вторую. Если и во второй окажется ссылка на другую функцию, 
вторая задача также будет отложена в стэк. Так будет продолжаться до тех пор, пока наконец какая-нибудь функция не вернёт конкретное значение. 
Тогда интерпретатор начнёт свой обратный путь по стэку для выполнения отложенных, ожидающих решения задач.

Пример:
#Напишите рекурсивную функцию multiply_lst(lst), которая перемножает элементы заданного списка lst между собой. 
#Если в функцию передаётся пустой список, она должна возвращать 1.

def multiply_lst(lst):
	
	if len(lst) == 0: return 1

	return lst[0] * multiply_lst(lst[1:])

print(multiply_lst([1, 5, 2, 1.5]))


Факториал через рекурсию. 4!= 4*3*2*1 =24
0!= 1
1!= 1

def factorial(n):
    # Задаём условия выхода из рекурсии:
    if n==0: return 1
    if n==1: return 1
    # Во всех других случаях возвращаем
    # произведение текущего числа n и функции от n-1
    return factorial(n-1)*n

print(factorial(5)) ---> 120

Глубина рекурсий.

Число единовременно ожидающих выполнения вызовов рекурсивной функции в стэке и называется глубиной рекурсии. 
Проще говоря, глубина рекурсии — это длина стэка вызова.
Например, при расчёте факториала от 3 функция factorial будет вызвана три раза: для расчёта факториала от 3, 2 и 1 соответственно. 
В какой-то момент все три вызова окажутся в стэке вызовов, а глубина рекурсии составит 3.  

Если удалить условия выхода из рекурсий или длина стека большая, то возникнет ошибка
  	if n==0: return 1
    if n==1: return 1

# RecursionError: maximum recursion depth exceeded    
Эта ошибка переводится так: «Ошибка рекурсии: превышена максимальная глубина рекурсии». 
Это своего рода встроенная защита от бесконечной рекурсии в Python.

На самом деле глубину рекурсии можно увеличить самостоятельно, 
если для решения вашей задачи крайне необходимо использовать рекурсию большей глубины.

# Импортируем модуль для работы с системными переменными
import sys
# Увеличим глубину рекурсии
sys.setrecursionlimit(1000000000)
print(len(str(factorial(970))))
# Будет напечатано:
# 2478

Рекурсии работают медленнее, чем аналогичные по сути циклы.

Пример:
#Напишите рекурсивную функцию power(val, n), которая возводит число val в заданную целую натуральную степень n (или в степень 0).

def power(val, n=0):

	if n < 1: 
		return 1
		
	return power(val,n-1)*val

print(power(2,3))

Пример:

#При разработке пользовательского интерфейса и программ, взаимодействующих с человеком, очень важна проверка корректности введённых 
#пользователем данных. Такую проверку в сообществе программистов принято называть «проверкой на дурака». 
#Некорректно введённые данные могут «сломать» вашу программу, если она не была подготовлена для их обработки.
#Напишите функцию check_date(day, month, year), которая проверяет корректность даты рождения по следующим условиям:
#Все аргументы должны быть целыми числами (проверить с помощью type(day) is int).
#Годом рождения не может быть год до 1900 и год после 2022.
#Номер месяца не может быть больше 12 и меньше 1.
#Номер дня не может быть больше 31 и меньше 1.
#В сентябре, апреле, июне и ноябре 30 дней.
#Если год является високосным, то в феврале (второймесяц) должно быть 29 дней, в противном случае — 28.
#Если дата корректна, вернуть True, если же хотя бы одно из представленных условий не было выполнено — False. 

def check_date(day, month, year):
    if type(day) is int and type(month) is int and type(year) is int:
        True 
    else:
        return False

    if 1900 < year <=2022:
        True
    else:
        return False

    if 1 <= month <= 12:
        True
    else:
        return False
    if 1 <= day <= 31:
        True 
    else:
        return False
                        
    if month == 4 or month == 6 or month == 9 or month == 11:
        if day <= 30:
            True
        else:
            return False
    else:
        True

    if year % 100 == 0 and year % 400 == 0 and month == 2 or year % 4 == 0 and year % 100 != 0 and month == 2:                      
        if day <= 29:
            return True     
        else:
            False

    if month == 2 and day <= 28:
        return True
    else: 
        return False
                    

print(check_date(29, 2, 2000))


Итератор:
В переводе с английского iterator означает «перечислитель». В Python это такая структура данных, которая позволяет выдавать объекты по одному,
когда её об этом просит пользователь.Объекты, из которых можно извлечь итератор, называются итерируемыми объектами. 
Примеры итерируемых объектов — список, кортеж, словарь, множество.
Чтобы получить итератор из структуры, используется функция iter().
К любому итератору можно применить функцию next(), которая возвращает следующий элемент из итератора. 
Каждый новый вызов next() уменьшает количество элементов в итераторе на 1, пока элементы не закончатся полностью.
Итератор является «одноразовым» объектом: как только элементы в итераторе заканчиваются, он становится по сути бесполезным. 


Пример:
users = [12, 14, 16]
iter_users = iter(users) 
print(next(iter_users)) ---> 12
print(next(iter_users)) ---> 14

Пример:
users = [12, 14, 16]
iter_users = iter(users) 

for i in iter_users:
    print(i) ---> 12  14  16



Пример:
users = [12, 14, 16]
iter_users = iter(users)

for i, user in enumerate(iter_users):
    # Выводим индекс и элемент на экран через двоеточие
    print(i, user, sep=': ') ---> 0: 12   1: 14    2: 16

Можно перебирать объекты из объекта enumerate по одному, как это было сделано выше в цикле for. 
При этом можно также собрать все элементы из итератора в список с помощью функции list():

users = ['admin', 'guest', 'root', 'anonymous']

# Создаём итератор enumerate из списка users
enum_users = enumerate(users)
# Получаем список из объекта enumerate
enum_list = list(enum_users)
print(enum_list)  ---> [(0, 'admin'), (1, 'guest'), (2, 'root'), (3, 'anonymous')]

Генераторы:
Генераторы — это объекты, которые при создании не вычисляют своё содержимое, но генерируют его в процессе работы. 
Они выдают своё содержимое по определённым правилам только по запросу разработчика.
Генератор объявляется как обычная функция. В теле функции описывается то, как будут генерироваться выдаваемые генератором объекты.
 Синтаксис имеет одно очень важное отличие: вместо ключевого слова return в генераторе используется yield. 

 Пример с бескочным циклом:
 # Объявляем функцию для расчёта суммы вклада
def deposit(money, interest):
    # Процент по вкладу преобразуем во множитель:
    # делим процент на 100 и прибавляем 1
    interest = interest/100 + 1
    # Создаем бесконечный цикл
    while True:
        # Сумма вклада через год — это
        # текущая сумма, умноженная на коэффициент и
        # округлённая до двух знаков после запятой
        money = round(interest * money, 2)
        # Выдаём полученную сумму вклада
        yield money

print(deposit(1000, 5)) ---> generator object deposit at 0x0000025DAA415270


bank = deposit(1000, 5)

print(next(bank)) ---> 1050.0
print(next(bank)) ---> 1102.5
print(next(bank)) ---> 1157.62

Если вместо return в функции используется yield, то при вызове функция возвращает объект-генератор. Сама функция при этом не выполняется,
пока мы не обратимся к генератору с помощью уже знакомой нам функции next().
Таким образом, генераторы действуют по принципу: «Решаем задачи по мере их поступления, пока задач нет — отдыхаем».
Оператор yield позволяет возвращать результат в основной блок кода и «замораживать» выполнение функции. Благодаря ему интерпретатор запоминает место, 
на котором он завершил работу с генератором, и возвращается на то же место при повторном обращении к генератору с помощью next().


Пример с условием выхода.
Давайте добавим генератор вклада, который автоматически закрывается через заданное число лет. Для этого объявим функцию deposit_years() 
с тремя аргументами: money — начальная сумма на счёте, interest — процент по вкладу и years — срок вклада (в годах). В отличие от прошлой функции, 
мы будем обновлять значение money не в бесконечном цикле, а в цикле for по диапазону от 0 до years.

# Объявляем функцию для расчёта суммы вклада
# Аргумент years принимает число лет, на которое рассчитан вклад
def deposit_years(money, interest, years):
    interest = interest/100 + 1
    # Вместо while используем цикл for с range
    for year in range(years):
        money = round(interest * money, 2)
        # Выдаём полученную сумму вклада
        yield money

bank2 = deposit_years(1500, 3, 2)

print(next(bank2)) ---> 1545.0
print(next(bank2)) ---> 1591.35
print(next(bank2)) ---> StopIteration


Пример без использования самостоятельно next:

def deposit_years(money, interest, years):
    interest = interest/100 + 1
    # Вместо while используем цикл for с range
    for year in range(years):
        money = round(interest * money, 2)
        # Выдаём полученную сумму вклада
        yield money



bank3 = deposit_years(1500, 3, 2)
for money in bank3:
    print(money)


Напомним, что на каждой итерации цикл for невидимо для нас вызывает функцию next().


Пример со списком:
def deposit_years(money, interest, years):
    interest = interest/100 + 1
    # Вместо while используем цикл for с range
    for year in range(years):
        money = round(interest * money, 2)
        # Выдаём полученную сумму вклада
        yield money

bank3 = deposit_years(10000, 10, 3)
sums = list(bank3)
print(sums) ---> [11000.0, 12100.0, 13310.0]

Когда мы обернули генератор в функцию list(), мы заставили его выдать нам все свои значения и занесли их в список.

Вычисление следующего значения происходит лишь при выполнении метода next(). Предыдущее значение при этом теряется. 
Например, в наших примерах мы генерировали бесконечную и конечную последовательность, управляя значением только одной переменной — money. 
Мы не сохраняли предыдущие значения нашего депозита — только выдавали текущее.
Таким образом мы получаем экономию расходуемой памяти. Это главное преимущество генераторов при работе с большим объёмом данных.

Пример:
#Напишите генератор group_gen(n). Он должен при каждом вызове выдавать порядковый номер от 1 до n (включая n). 
#После достижения n генератор должен снова возвращать номера, начиная с 1.

def group_gen(n):
    while True:
        for i in range(1, n+1):
            yield i
            
a = group_gen(5)
print(next(a))


Сокращённая запись генераторов:

squares_generator = (x**2 for x in range(1, 11))
# Оборачиваем сгенерированные элементы в список:
squares_list = list(squares_generator)
print(squares_list) ---> [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

for i in squares_generator:
    print(i) ---> 1 4 9 16 25 36 49 64 81 100


Пример:
# Создаём генератор кубов чисел, которые делятся на 3
triple_cubes_generator = (x**3 for x in range(1,16) if x % 3 == 0)
print(type(triple_cubes_generator))  ---> # <class 'generator'>
# Оборачиваем сгенерированные значения в список
print(list(triple_cubes_generator)) ---> #[27, 216, 729, 1728, 3375]


Пример:
Можно генерировать списки сразу, без необходимости применения функции list() 

triple_cubes_list = [x**3 for x in range(1,16) if x % 3 == 0]
print(type(triple_cubes_list)) ---> #<class 'list'>

print(triple_cubes_list) ---> #[27, 216, 729, 1728, 3375]

Генератор множества:
triple_cubes_set = {x**3 for x in range(1,16) if x % 3 == 0}
print(type(triple_cubes_set)) ---> # <class 'set'>
print(triple_cubes_set) ---> # {1728, 3375, 216, 729, 27}

А вот кортеж так получить не выйдет, поскольку круглые скобки используются для создания генераторов. 

triple_cubes_tuple = tuple(x**3 for x in range(1,16) if x % 3 == 0)
print(type(triple_cubes_tuple)) ---> #<class 'tuple'>
print(triple_cubes_tuple) ---> #(27, 216, 729, 1728, 3375)


функция map() применяет одну и ту же функцию к каждому элементу итерируемого объекта.
Объект типа map на самом деле является разновидностью итератора, а значит можно получить его элементы, последовательно применяя функцию next():
names = ['Ivan', 'Nikita', 'Simon', 'Margarita', 'Vasilisa', 'Kim']

# Объявляем функцию для вычисления длины
def get_length(word):
    return len(word)
# Применяем функцию get_length к каждому элементу списка
lens = map(get_length, names)



print(next(lens)) ---> 4

for i in lens:
    print(i)  --->  4 6 5 9 8 3

Сразу в список
print(list(lens)) ---> [4, 6, 5, 9, 8, 3]

Пример с lambda:

names = ['Ivan', 'Nikita', 'Simon', 'Margarita', 'Vasilisa', 'Kim']

lens = list(map(lambda x: len(x), names))
print(lens)  ---> [4, 6, 5, 9, 8, 3]


Пример с объединением двух строк в списке:

docs = [
    '//doc/5041434?query=data%20science',
    '//doc/5041567?query=data%20science',
    '//doc/4283670?query=data%20science',
    '//doc/3712659?query=data%20science',
    '//doc/4997267?query=data%20science',
    '//doc/4372673?query=data%20science',
    '//doc/3779060?query=data%20science',
    '//doc/3495410?query=data%20science',
    '//doc/4308832?query=data%20science',
    '//doc/4079881?query=data%20science'
]



main_link = "https://www.kommersant.ru"


links = list(map(lambda x: main_link + x, docs))
print(links) ---> ['https://www.kommersant.ru//doc/5041434?query=data%20science', 'h.....']

функции filter() позволит отфильтровать переданный ей итерируемый объект и оставить в нём только те элементы, которые удовлетворяют условию.
Её использование аналогично применению функции map().

# Объявляем функцию для проверки чётности числа
def is_even(num):
    if num % 2 == 0:
        return True
    return False


lens_list = [4, 6, 5, 9, 8, 3]
# Применяем функцию is_even к каждому элементу списка
even = filter(is_even, lens_list)

print(list(even)) ---> [4, 6, 8]


Пример с lambda:

lens_list = [4, 6, 5, 9, 8, 3] 
# Применяем lambda-функцию к каждому элементу списка
even = filter(lambda x: x % 2 == 0, lens_list)
print(list(even)) ---> [4, 6, 8]

Пример:

#Вы — сотрудник отдела разработки в МФЦ. МФЦ предоставляет некоторый спектр услуг многодетным семьям. Необходимо написать функционал, 
#который позволяет отфильтровать среди всех запрашиваемых пользователем услуг (их количество произвольное) только те, которые предоставляются многодетным семьям.

family_list = [
    'certificate of a large family',
    'social card',
    'maternity capital',
    'parking permit',
    'tax benefit',
    'reimbursement of expenses',
    "compensation for the purchase of children's goods"
    ]



def family(*args):
    for i in args:
        
        return (list(filter(lambda x:x in family_list, i)))
        

print(family(['social card', 'medical policy', 'maternity capital']))


Конвейеры из map И filter

Иногда возникает задача выполнить сразу несколько действий с объектами из итератора. Например, вы хотите масштабировать данные об оценках вашей видеоигры пользователями, 
а затем отфильтровать оценки. Такие преобразования называются конвейерными.

names = ['Ivan', 'Nikita', 'Simon', 'Margarita', 'Vasilisa', 'Kim']

# Отбираем имена из пяти и более букв
long_names = filter(lambda x: len(x) >= 5, names)
# Все отобранные имена переводим в верхний регистр и считаем число букв А в них
# Результат сохраняем в виде кортежа (имя, число букв "A")
count_a = map(lambda x: (x, x.upper().count('A')), long_names)
# Переводим объект map в list и печатаем его
print(list(count_a)) ---> [('Nikita', 1), ('Simon', 0), ('Margarita', 3), ('Vasilisa', 2)]


Пример:

#Выберите из списка reg только те записи, в которых год рождения пользователя 2000 и больше (2001, 2002 и т. д.). 
#Из оставшихся записей составьте новый список кортежей, в котором фамилия и имя объединены в одну строку по следующему шаблону Фамилия И. 
#(обратите внимание на точку после сокращения имени).



reg = [('Ivanov', 'Sergej', 24, 9, 1995),
      ('Smith', 'John', 13, 2, 2003),
      ('Petrova', 'Maria', 13, 3, 2003)]

reg_filter = filter(lambda x:x[4]>2000, reg)
new_reg = list(map(lambda y: (y[0] +' '+ y[1][0]+ '.',y[2],y[3],y[4]), reg_filter))


print(new_reg)



Функция zip():

Результат работы функции zip() — специальный итератор zip. При требовании получить следующий объект (вызове next()) 
итератор выдаёт кортеж, в котором по порядку перечислено по одному объекту из каждого аргумента.
В итоге мы получаем параллельную обработку нескольких коллекций объектов сразу.
Важное замечание: zip перестаёт выдавать элементы тогда, когда заканчиваются элементы в самом коротком итераторе.

surnames = ['Ivanov', 'Smirnov', 'Kuznetsova', 'Nikitina']
names = ['Sergej', 'Ivan', 'Maria', 'Elena']
# Создаём цикл по элементам итератора zip — кортежам из фамилий и имён
for surname, name in zip(surnames, names):
    print(surname, name) ---> Ivanov Sergej Smirnov Ivan ...



Пример:
Перед вами стоит задача разбить пользователей на три группы, чтобы в дальнейшем проводить А/B/C-тестирование.


def group_gen(n=3):
    while True:
        for i in range(1, n+1):
            yield i

def print_groups(users):

    for users, group in zip(users,  group_gen()):


        print(users, 'in group', group)


print_groups(users = ['fewq m.', 'asdfd f.', 'ghjyh v.', 'bhnh v.']) ---> #fewq m. in group 1, asdfd f. in group 2, ghjyh v. in group 3 bhnh v. in group 1



Декораторы:
Декораторы — это функции, которые изменяют поведение основной функции таким образом, что она продолжает принимать и возвращать те же значения, однако её функционал расширяется.


def logger(name):

    def decorator(func):

        def decorated_func(*args, **kwargs):
            print (name + ':', 'Function', func.__name__, 'started')
            res = func(*args, **kwargs)
            print (name + ':', 'Function', func.__name__, 'finished')
            return res

        return decorated_func

    return decorator


@logger('MainLogger')
def root(val, n=2):
    res = val ** (1/n)
    return res

print(root(25))

#Результат:
#MainLogger: Function root started
#MainLogger: Function root finished
#5.0


    b=text.replace(',','')
    text.replace(';','')
    text.replace(':','')
    text.replace('...','')
    text.replace('!','')
    text.replace('?','')
    text.replace('-','')
    text.replace('"','')
    text.replace(',','')
    text.replace('(','')
    text.replace(')','')