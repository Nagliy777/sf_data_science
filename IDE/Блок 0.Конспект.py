
ДАННЫЕ	                     ТИП	             ПРИМЕРЫ

Целые числа                  int                   73
Числа с плавающей точкой     float                3.14
Строки                       str              "Hello, world!"
Логические переменные        bool             True  False
Списки                       list              [1,2,3,4]
Кортежи                      tuple            (‘a’,’b’,’c’)
Словари                      dict             {‘a’ : 1, ‘b’ : 2}  
Множества                    set              {‘a’, 1, ‘b’, 2}

НЕИЗМЕНЯЕМЫЕ ТИПЫ	                ИЗМЕНЯЕМЫЕ ТИПЫ
Целые числа (int)	                  Списки (list)
Числа с плавающей точкой (float)	   Словари (dict)
Строки (str)	                      Множества (set)
Логические переменные (bool)	
Кортежи (tuple)

type узнать тип данных
a = 'aaa'.
if type(a) is str:
print(True)

ОПЕРАЦИЯ	          ОБОЗНАЧЕНИЕ	       ПРИМЕР
Сложение	             +	              7+5 = 12
Вычитание	             –	              7-5 = 2
Умножение	             *	              7*5 = 35
Возведение в степень	 **	              7**5 = 16807
Деление	                 /	              5/2 = 2.5
Целочисленное деление	//	              7//5 = 1
Остаток от деления   	%	              7%5 = 2

round(): округление чисел.
print(round(3.14/2, 1)) # второй аргумент — желаемое количество знаков


#? Строки

s = "Hello!"               Задаём строку
s[начало:конец:шаг]        Срез строки
s = "Hel" + “lo!"          Сложение строк
s = "Hello!"*n            Дублирование значения строки n раз
len(s)                     Длина строки
find(substr)             Метод для поиска подстроки в строке Пример вызова: s.find('e')
                         возвращает индекс символа 'e' в строке s
isdigit()               Метод возвращает True, если строка состоит только из цифр
isalpha()                Метод возвращает True, если строка состоит только из букв
isalnum()                Метод возвращает True, если строка состоит только из букв и цифр
upper()                  Метод возвращает новую строку в верхнем регистре
lower()                  Метод возвращает новую строку в нижнем регистре
split(разделитель)       Метод разбивает строку на части по
разделителю (по умолчанию — пробел) и возвращает результат в виде списка
'строка-разделитель'.join(список)  Метод объединяет элементы списка в строку, 
                                     вставляя между ними строку-разделитель
f-строки          f'The {currency} currency rate on the date {cur_date} is {rate:.3f}'

#? Создание списка

a = []
a = list()
a = [1,2,3]
a = ["h", "hello", "world", "a"]
a = range(0,10)
a = range(0,10, 2)
a = range(10)
list1 = ["hello", 4, 3.5, (1,2), [1,2,3], {"name": "Bob", "age": 33}]

#? Индексы и срезы

a[2]
a[-1]
a[:2]
a[1:3]
a[0:3:2]
a[::-1]

#? Работа со списком

Вставка                a.append(“new_elem”)
Подсчёт                a.count(“new_elem”)
Копирование            b = a.copy()
Расширение             a.extend([“another”, “list”, “with”, “some”, “elements”])
Реверс                 a.reverse(), a[::-1]
Сортировка             a.sort()
Очистка                a.clear()

s = "hello"
s[0] # ‘h’
s[:2] # ‘he’

#? Кортеж
tpl1 = ()
tpl1 = tuple()
tpl1 = (1,2,3)
tpl1 = (1,)
tpl1 = ("hello", 4, 3.5, (1,2), [1,2,3], {"name": "Bob", "age": 33})

Кортежи — неизменяемые братья для списков. Можно использовать в ключах
для словаря

#? Словарь

dict1 = dict()
dict1 = {}
dict1 = {"name": "Bob", (1,2): 3, 3.5: [1,2,3]}

Взятие ключей dict1.keys()
Взятие значений dict1.values()

Обращение по ключу         dict1[“name”]
Метод .clear(), friends = {}   Очистка
Метод .get() Обращение по ключу с дефолтным значением
«Умная» замена обычному обращению по ключу через квадратные скобки. Если использовать только квадратные скобки при обращении 
к словарю, то при отсутствии нужного ключа программа выдаст ошибку и закончит работу.
В случае с .get() программа продолжит работать, но вернёт константу None — единственного представителя типа NoneType, 
который показывает, что значения нет, оно пусто.
Также .get() позволяет вывести значение по умолчанию для отсутствующего ключа. Это второй аргумент в методе .get():
#print(friends.get("Matvey", 'Netu')) -----> Netu
Метод .update() добавляет сразу несколько ключей и значений в словарь, а таже меняет существующее зачение.
#friends.update({'Tamara': 177, 'Bilbo':777, "Misha": 159})
Метод .pop() удаляет из структуры данных элементы, но дополнительно метод возвращает результат в новую переменную.
Метод .setdefault() принимает два параметра: ключ и значение по умолчанию, если этого ключа нет в словаре.
Если ключ имеется, его значение останется неизменным

#? Множество

set1 = set()
set1 = set([1,2,2,2,2,1])
set1 = {33}
set1 = {33, 22, 33, 1}
set1 = {33, 2.3, "hello", (1,2,3)}

Методы множеств

Метод .add() быстро и безболезненно добавить новый элемент в множество можно
#s = {1, 2, 3, 4}
#s.add(5)
#print(s) -----> {1, 2, 3, 4, 5}
Метод .update() добавляет во множество сразу несколько элементов.
#a = {1, 2, 3, 4}   Множество
#b = [5, 6, 7]      Список
#c = {'a':1, 'b':2} Словарь
#a.update(b)
#a.update(c)
#print(a) -----> {1, 2, 3, 4, 5, 6, 7, 'a', 'b'}
Методы .discard(), .remove() 
Их отличие друг от друга состоит в том,что при удалении уже отсутствующего элемента из множества discard() 
ничего не сделает, а вот .remove() выкинет ошибку.Суть выбора заключается в логике вашего алгоритма. 
Если вам важно, чтобы удаление элемента было явным, используйте метод .remove().
#s1 = {1,2,3,4,5}
#s1.remove(10)
#print(s1)  -----> KeyError: 10
#s1 = {1,2,3,4,5}
#s1.discard(10)
#print(s1)  -----> {1, 2, 3, 4, 5}
Метод .union() берёт все имеющиеся элементы в двух множествах ровно один раз. 
Порядок следования элементов может не соблюдаться.
#cluster1 = {"item1", "item2", "item3", "item4"}
#cluster2 = {"item2", "item3", "item5", "item7"}
#print(cluster1.union(cluster2)) -----> {'item3', 'item2', 'item7', 'item4', 'item1', 'item5'}

Метод .intersection() берутся все элементы, которые есть в обоих множествах.Ровно один раз.
#cluster1 = {"item1", "item2", "item3", "item4"}
#cluster2 = {"item2", "item3", "item5", "item7"}
#print(cluster1.intersection(cluster2)) -----> {'item3', 'item2'}

Метод .difference() выбирает все элементы из первого множества, которых нет во втором множестве.
#cluster1 = {"item1", "item2", "item3", "item4", "item5"}
#cluster2 = {"item3", "item4", "item5", "item6"}
#print(cluster1.difference(cluster2)) -----> {'item2', 'item1'}

Метод .issubset() используется для того, чтобы узнать, все ли элементы из первого множества есть во втором множестве.
#cluster1 = {"item1", "item2", "item3"}
#cluster2 = {"item2", "item3", "item4", "item5", "item6"}
#print(cluster1.issubset(cluster2)) -----> False

#? Преобразование типов

#* Вещественное число в целое число:   float_to_int = int(3.4)
#* Целое число в вещественное число   int_to_float = float(3)
#* Вещественное число в строку        float_to_string = str(3.4)
#* Целое число в строку               int_to_string = str(3)
#* Строка в вещественное число        string_to_float = float(“3.4”)
#* Строка в целое число s              tring_to_int = int(“3”)
#* Список в кортеж                     list_to_tuple = tuple([1,2,3])
#* Кортеж в список                       tuple_to_list = list((1,2,3))


#? Логические операторы
not	        Логическое «НЕ»	Возвращает противоположное значение
or	        Логическое «ИЛИ»	Возвращает True, если хотя бы одна из переменных True
and	        Логическое «И»	Возвращает True, если обе переменные True
in, not in	Проверка принадлежности	Возвращает True, если проверяемая переменная содержится/не содержится в последовательности (списке, кортеже, строке...)
is, is not	Проверка тождественности	Возвращает True, если проверяемые объекты эквивалентны/не эквиваленты. То есть переменные ссылаются на один и тот же адрес в памяти компьютера

#? Циклы

Цикл for
for value in iterator:
# Начало блока кода с телом цикла
...
...
...
# Конец блока кода с телом цикла
# Код, который будет выполняться после
цикла

Цикл while с предусловием

while условие:
# Начало блока кода с телом цикла
# Пока условие истинно, цикл
выполняется
...
...
...
# Конец блока кода с телом цикла
# Код, который будет выполняться после
цикла


Цикл while с постусловием

while True:
# Начало блока кода с телом цикла
# Пока условие истинно, цикл
выполняется
...
...
...
# Конец блока кода с телом цикла
if условие:
break
# Код, который будет выполняться после
цикла

# Хорошо
a is None
# Хорошо
if not seq:
if seq:
# Хорошо
if greeting:

#? Функции

# В круглых скобках называем аргументы
def new_function(arg1, arg2):
# Прописываем инструкции
...
# Возвращаем результаты
return result1, result2

#* Проверка аргументов

def get_time(dist, speed):
# Проверяем аргумент с помощью условия
if speed <= 0:
# С помощью raise возвращаем ValueError
raise ValueError("Speed can’t be less than 0")
# Инструкции для корректных аргументов
...

#* Аргументы по умолчанию

# С помощью '=' присваиваем
# значение по умолчанию
def root(value, n=2):
return value ** (1/n)
# Изменяемые типы данных должны
# создаваться в самом теле функции!
def new_function(in_list=None):
if in_list is None:
in_list = list()
...

#* Получение переменного числа аргументов

def new_function(*args, **kwargs):
# В переменной args — кортеж из
# порядковых аргументов
# В kwargs — словарь из именованных

*args. Здесь * — это не символ умножения, а оператор распаковки.
После аргументов, записанных через *args, не могут идти другие порядковые аргументы.
Необходимо запомнить, что все аргументы, следующие за конструкцией с оператором *, считаются именованными.

# В массив args будут записаны все переданные
# порядковые аргументы
def mean(*args):
    # Среднее значение — это сумма всех значений,
    # делённая на число этих значений
    # Функция sum — встроенная, она возвращает
    # сумму чисел
    result = sum(args) / len(args)
    return result
 
# Передадим аргументы в функцию через запятую,
# чтобы посчитать их среднее
print(mean(5,4,4,3)) ---> 4.0

С помощью оператора ** можно передавать в функцию нескольких аргументов. 
Он используется для передачи именованных аргументов с помощью словаря,
который в дальнейшем будет распакован. 

def schedule(**kwargs):
    print("Week schedule:")
    for key in kwargs:
        print(key, kwargs[key], sep=' - ')

schedule(monday='Python', tuesday='SQL', friday='ML')
# Будет напечатано:
# Week schedule:
# monday — Python
# tuesday — SQL
# friday — ML

#* Передача аргументов

# Сначала порядковые, затем — именованные аргументы
new_function("Arg1", 24, city="Moscow")
# Распаковка списков и словарей в функцию:
new_list = [1,3,4,5]
how = {'sep': ', ', 'end': '; '}
# С помощью операторов * и **
print(*new_list, **how)
# 1, 3, 4, 5;

#* Lambda-функции

lambda-функции. Она позволяет быстро создавать короткие однострочные функции, 
для которых нет необходимости прописывать целиком сигнатуру и оператор return.

# От одного аргумента:
get_length = lambda x: len(x)
# От двух
mult = lambda x,y : x*y
# От неограниченного числа:
all_args = lambda *args, **kwargs:(args, kwargs)
l = ['dd', 'bbb', 'aaa']
# Сортировка с lambda по длине слова,
# потом — по алфавиту
l.sort(key=lambda x: (len(x), x))

#? Продвинутые функции

#! Пример:
#объявляем внешнюю функцию для регистрации сотрудников
def register_employee(name, surname):
    #объявляем функцию для промежуточных вычислений
    def create_full_name():
        #функция использует внешние переменные name и surname
        sep = ' ' #разделитель между именем и фамилией
        result = name + sep + surname #вычисляем полное имя
        return result
    full_name = create_full_name() #вызываем внутреннюю функцию
    #выводим результат на экран, используя внешнюю переменную company_name
    print('Employee {} is registered with the company {}'.format(full_name, company_name))
    
company_name = 'TheBlindMice' #название компании
register_employee('John','Doe') вызов функции  ---> Employee John Doe is registered with the company TheBlindMice

#* 2.Нелокальные переменные (nonlocal) — это переменные, которые были объявлены во внешней функции относительно рассматриваемой функции.

#*2.1.Переменные name и surname являются нелокальными по отношению к функции create_full_name(). 
#*Они объявлены во внешней функции и используются во внутренней.

#*3.Глобальные переменные (global) — это переменные, которые были объявлены непосредственно в основном блоке программы (вне функций).

#*3.1.Переменная company_name объявлена в основной части программы (вне функции) и является глобальной.
#*Обратите внимание, что она задана после объявления функции. Ошибки не возникает, потому что код выполняется построчно, 
#*а значит сначала создаётся переменная company_name, а затем она уже используется в вызове функции  register_employee(). 
#*Если бы мы поменяли вызов функции и объявление переменной местами, получили бы ошибку.

#*4.Встроенные переменные (built-in) — это переменные и объекты, которые встроены в функционал Python изначально. 
#*Например, к ним относятся функции print, len, структуры данных list, dict, tuple и другие. 
#*В большинстве IDE, таких как PyCharm, VS Code и Jupyter, имена таких переменных подсвечиваются специальным цветом.

#*4.1.Функция print() является встроенной функцией Python. К ней можно обращаться из любой части программы.


#? Рекурсии

#todo функция map() применяет одну и ту же функцию к каждому элементу итерируемого объекта.
#todo Объект типа map на самом деле является разновидностью итератора, а значит можно получить его элементы, последовательно применяя функцию 

# Объявляем функцию для вычисления длины
def get_length(word):
    return len(word)
# Применяем функцию get_length к каждому элементу списка
lens = map(get_length, names)

print(next(lens)) ---> 4

#* Или 
for i in lens:
    print(i)  --->  4 6 5 9 8 3


#* Пример с lambda:

names = ['Ivan', 'Nikita', 'Simon', 'Margarita', 'Vasilisa', 'Kim']

lens = list(map(lambda x: len(x), names))
print(lens)  ---> [4, 6, 5, 9, 8, 3]

#todo функции filter() позволит отфильтровать переданный ей итерируемый объект и оставить в нём только те элементы, которые удовлетворяют условию.
#todo Её использование аналогично применению функции map().

# Объявляем функцию для проверки чётности числа
def is_even(num):
    if num % 2 == 0:
        return True
    return False


lens_list = [4, 6, 5, 9, 8, 3]
# Применяем функцию is_even к каждому элементу списка
even = filter(is_even, lens_list)

print(list(even)) ---> [4, 6, 8]


#todo Функция zip():

#*Результат работы функции zip() — специальный итератор zip. При требовании получить 
#*следующий объект (вызове next()) итератор выдаёт кортеж, в котором по порядку перечислено
#*по одному объекту из каждого аргумента.В итоге мы получаем параллельную обработку 
#*нескольких коллекций объектов сразу.Важное замечание: zip перестаёт выдавать элементы тогда,
#*когда заканчиваются элементы в самом коротком итераторе.

surnames = ['Ivanov', 'Smirnov', 'Kuznetsova', 'Nikitina']
names = ['Sergej', 'Ivan', 'Maria', 'Elena']
# Создаём цикл по элементам итератора zip — кортежам из фамилий и имён
for surname, name in zip(surnames, names):
    print(surname, name) ---> Ivanov Sergej Smirnov Ivan ...
    
#! Сложение двух списков
list1 = [2, 4, 7, 2.5]
list2 = [12, 6, 3.6, 13]
[x + y for x, y in zip(list1, list2)] ---> [14, 10, 10.6, 15.5]


#? Декораторы

def decorator(func):
# Декорирующая функция
def decorated(*args, **kwargs):
# Дополнительные действия "до"
...
res = func(*args, **kwargs)
# Дополнительные действия "после"
...
return res
return decorated
# Применяем декоратор через @
@decorator
def my_function(arg): ...

#? Итераторы

my_list = [1, 4, 6]
# Получить итератор из списка:
iter_list = iter(my_list)
# Получить следующий объект:
elem = next(iter_list)
# Перебрать все элементы из итератора
for elem in iter_list:
...
# Записать все значения в список:
new_list = list(iter_list)

#? Генераторы

def my_generator(num):
for i in range(num):
# Используем yield для выдачи результата
yield i
# Выполнение функции замораживается
# Получить экземпляр итератора:
new_gen = my_generator(5)
# Генератор — тоже итератор:
elem = next(new_gen)
# Сгенерировать всё в список:
l = list(new_gen)

#? Списочные сокращения

# Получить генератор в одну строку:
gen = (x**2 for x in range(10))
# Сохранить результаты в список:
new_list = [x**2 for x in range(10)]
# Или во множество:
new_list = {x**2 for x in range(10)}
# Или в кортеж
new_list = tuple(x**2 for x in range(10))
# Воспользоваться условием:
gen = (x**2 for x in range(10)\
if x%2 == 0)

#? Функции для итераторов

# Применить функцию к итератору
map(function_name, my_iterator)
# Отобрать элементы по условной функции:
filter(condition, my_iterator)
# Сгруппировать элементы из итератора:
list1 = [1,3,4,6]
list2 = [5,9,10,13]
for a, b in zip(list1, list2):
print(a, b)




