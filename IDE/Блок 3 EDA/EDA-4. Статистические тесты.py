
#! Статистические тесты: введение

#? ОСНОВНЫЕ ТИПЫ СТАТИСТИЧЕСКИХ ТЕСТОВ

#* Далее мы будем говорить о статистических тестах для количественных признаков,
#* так как они состоят из большего числа этапов и задачи с количественными признаками
#* чаще встречаются на практике. Тесты для категориальных признаков мы рассмотрим в
#* юните «Статистические тесты для категориальных признаков».

#? Выбор статистического теста для количественных признаков зависит от ряда факторов:

#* количества анализируемых групп (выборок): одна, две, три и более групп;
#* зависимости групп: зависимые и независимые;
#* знания о распределении признаков по нормальному закону.
#* Ниже мы рассмотрим каждый из этих факторов.

#? КРИТЕРИЙ ВЫБОРА ТЕСТА: КОЛИЧЕСТВО ГРУПП

#*Количество групп определяется значением фактора, влияние которого мы анализируем, например:

#* Чтобы определить, достигается ли целевой показатель «среднее время посещения сайта — пять минут»,
#* понадобится случайным образом набрать из посетителей этого сайта одну группу.
#* Для определения эффекта от лекарства понадобится две группы: пациенты, не принимающие лекарство
#* (контрольная группа), и пациенты, принимающие его (тестовая группа).
#* Чтобы выяснить, влияет ли цвет машины на её стоимость, понадобится количество групп, равное
#* анализируемому количеству цветов: белый, чёрный, красный, серый и т. д.

ТИП ТЕСТА	                  ПРИМЕР ЗАДАЧИ
#* Одновыборочный	      Равно ли среднее время посещения сайта пяти минутам?
#* Двухвыборочный	      Выздоравливают ли пациенты, принимающие лекарство, быстрее, чем те, которые его не принимают?
#* Многовыборочный	      Влияет ли цвет машины на её стоимость?

#? КРИТЕРИЙ ВЫБОРА ТЕСТА: ЗАВИСИМОСТЬ ГРУПП

#* В независимых группах набор объектов в одну группу проходит независимо от набора объектов в другие группы.
#* Примеры: случайное деление школьников внутри одного класса, случайный набор в группы из всего множества
#* пользователей приложения.

#* В зависимых группах каждый объект одной группы связан с объектом в другой группе. Такая ситуация
#* возникает, например, когда мы анализируем признаки в динамике.
#* Примеры: покупатели до получения рассылки и эти же покупатели после её получения, пациенты
#* до начала лечения и эти же пациенты после его окончания.

#* Тесты, разработанные для сравнения независимых групп, называются непарными,
#* тесты для сравнения зависимых групп — парными.

#?  КРИТЕРИЙ ВЫБОРА ТЕСТА: РАСПРЕДЕЛЕНИЕ ПРИЗНАКА ПО НОРМАЛЬНОМУ ЗАКОНУ

#* Если признаки распределены по нормальному закону, к ним можно применять параметрические
#* тесты — статистические методы, основанные на параметрах нормального распределения (среднее значение,
#* стандартное отклонение).

#* Если мы знаем, что признаки не распределены нормально или у нас нет информации об их распределении,
#* необходимо использовать непараметрические тесты. Их можно применять на любых количественных признаках
#* независимо от вида их распределения. Непараметрические методы менее чувствительны к выбросам в данных.

#? АЛГОРИТМ ВЫБОРА ТЕСТА ДЛЯ КОЛИЧЕСТВЕННЫХ ПРИЗНАКОВ

Например, в задаче, зависит ли средний чек покупки от пола покупателей, шаги по выбору теста будут такими:

#* Какой тип у признака «средний чек»?
#* Количественный.

#* Сколько сравниваемых групп?
#* Две (мужчины и женщины).

#* Группы зависимы?
#* Нет, так как объекты в выборках не повторяются.

#* Признак распределён по нормальному закону?
#* Если да, нужен двухвыборочный t-критерий.
#* Если нет, нужен U-критерий Манна — Уитни.

#todo Примечание. Для сравнения групп одновременно по нескольким признакам используют методы двумерного
#todo и многофакторного анализа, например, регрессионный анализ, многофакторный дисперсионный анализ и др.
#todo Пример бизнес-задачи: оценка влияния уровня образования (среднее профессиональное, высшее, научная степень) на зарплату и число полётов за границу в год.

#! Проверка на нормальность

#* В предыдущем юните мы говорили, что для выбора между параметрическими и непараметрическими тестами
#* необходимо проверить распределение признаков на нормальность. Сейчас мы узнаем, что такое нормальное
#* распределение, почему оно так важно для нас и как проверить, подчиняется ли распределение данных
#* нормальному закону.

#* Начиная с этого раздела, мы будем практиковаться на Python. Для этого нам понадобятся две новых библиотеки:

#* SciPy — библиотека для научных и инженерных расчётов.
#* Statsmodels — библиотека для статистических исследований.

#* Установить эти библиотеки можно с помощью стандартной команды:
#* ! pip install scipy
#* ! pip install statsmodels

#? НОРМАЛЬНОЕ РАСПРЕДЕЛЕНИЕ

#* Многие процессы в природе следуют нормальному закону распределения: рост человека, вес при рождении,
#* артериальное давление, размер ноги и др.

#* На курсе вы уже сталкивались с понятием нормального распределения и некоторыми теоремами и правилами,
#* основанными на особенностях нормального распределения. В частности в модуле «Очистка данных» мы изучали
#* метод z-отклонений (трёх сигм) и метод Тьюки для поиска выбросов — они работают только для нормально
#* распределённых данных.

#* Нормальное распределение (распределение Гаусса) характеризуется двумя числами:

#* средним значением  (mu);
#* стандартным отклонением  (sigma).

#todo Любое нормальное распределение обладает следующими свойствами:

#* Один пик в центре и симметричные боковые стороны (одномодальное распределение).
#* Среднее и медиана равны и расположены в центре распределения.
#* Отклонение значений от среднего подчиняется правилу трёх сигм:
#* 68 % значений находятся в пределах одного стандартного отклонения от среднего;
#* 95 % значений — в пределах двух стандартных отклонений;
#* 99.7% значений — в пределах трёх стандартных отклонений.

#? ГРАФИЧЕСКИЕ МЕТОДЫ ПРОВЕРКИ НА НОРМАЛЬНОСТЬ

#todo ГИСТОГРАММА

#* Если гистограмма имеет вид колокола, то мы считаем, что данные в выборке распределены нормально

#* Напомним, что в Python гистограмму можно построить с помощью функции histplot() пакета seaborn.
#* Параметр kde=True добавляет к гистограмме график оценки плотности ядра.

#* Рассмотрим эту функцию на примере датасета California Housing, входящего в состав sklearn.
#* Построим гистограмму распределения целевого признака — стоимости домов:

# импортируем библиотеки
import pandas as pd
from sklearn import datasets
from matplotlib import pyplot as plt
import seaborn as sns

# загружаем данные
dataset = datasets.fetch_california_housing()
data = dataset.target

# задаём параметры гистограммы
ax = sns.histplot(data, bins=30, kde=True)
ax.set(xlabel='Значение признака', ylabel='Частота')
plt.title('Гистограмма распределения стоимости домов')

# отображаем гистограмму
plt.show()

#* Форма гистограммы несимметрична, с двумя пиками. Отсюда делаем промежуточный вывод:
#* распределение стоимости домов не является нормальным.

#todo КВАНТИЛЬ-КВАНТИЛЬ ГРАФИК

#* Квантиль-квантиль график (Q-Q Plot) визуализирует, насколько распределение выборки близко к
#* нормальному. График показывает взаимное расположение квантилей наблюдаемого и теоретического
#* нормального распределения. Хороший гайд по Q-Q Plots.

#* Если все точки лежат вдоль диагонали, то мы считаем, что данные в выборке распределены нормально

#* В Python квантиль-квантиль график можно построить с помощью функции qqplot() пакета statsmodels.
#* Построение квантиль-квантиль графика мы также рассмотрим на примере стоимости домов из
#* датасета California Housing:

import numpy as np
import statsmodels.api as sm
from sklearn import datasets
from matplotlib import pyplot as plt

# загружаем данные
dataset = datasets.fetch_california_housing()
data = dataset.target

# задаём параметры квантиль-квантиль графика
sm.qqplot(data, line='s')
plt.title('Квантиль-квантиль график \n для распределения стоимости домов')

# отображаем квантиль-квантиль график
plt.show()

#* Точки не располагаются на диагонали — распределение стоимости домов не является
#* нормальным (как мы видели и по гистограмме).

#* Графические методы могут быть неудобны в граничных случаях, когда сложно визуально определить,
#* нормально ли распределение. Например, распределение может быть симметричным и похожим на колокол,
#* но не соответствовать другим признакам нормального распределения. Также гистограмма и Q-Q Plot
#* неинформативны на маленьких выборках.
#* В таких случаях на помощь приходят специальные статистические тесты.

#? СТАТИСТИЧЕСКИЕ МЕТОДЫ ПРОВЕРКИ НА НОРМАЛЬНОСТЬ

#* Существует несколько статистических методов, которые позволяют получить количественную оценку
#* для проверки на нормальность. Мы рассмотрим наиболее часто встречающийся метод — тест Шапиро — Уилка.

#* Тест Шапиро — Уилка оценивает выборку данных и определяет, насколько вероятно, что данные
#* были получены из нормального распределения.

#* Тест хорошо работает на выборках до 5000 объектов.

#todo Гипотезы в основе теста:

#* Нулевая: данные распределены нормально.
#* Альтернативная: данные не распределены нормально.

#* Если p-value теста больше уровня значимости , то мы считаем, что данные распределены нормально.

#todo ПРИМЕР ИСПОЛЬЗОВАНИЯ ТЕСТА НА PYTHON

#* Допустим, нам необходимо проверить, нормально ли распределение количества заказов в день в некотором
#* интернет-магазине. Чтобы правильно выбрать тест, количество заказов нужно проверить на нормальность:

import scipy.stats as stats

# задаём уровень значимости
alpha = 0.05 

# загружаем данные
data = [31, 38, 30, 58, 40, 36, 38, 44, 43, 39, 36, 41, 37, 20, 38, 35, 38, 11, 42, 34]

# проводим тест Шапиро — Уилка
_, p = stats.shapiro(data)

print('p-value = %.3f' % (p))

# интерпретируем результат
if p <= alpha:
    print('Распределение не нормальное')
else:
    print('Распределение нормальное')

# p-value = 0.015
# Распределение не нормальное

#! Параметрические тесты

#* В предыдущем юните мы рассмотрели методы проверки на нормальность. Она необходима, чтобы выбрать,
#* какие статистические тесты использовать:

#* параметрические, если распределение признака нормальное;
#* или непараметрические, если распределение признака отлично от нормального или о нём нет информации.
#* В этом юните мы:

#* разберём параметрические тесты, которые упомянули в алгоритме выбора статистического теста для
#* количественных признаков;
#* для каждого теста приведём описание функции, которая реализует его в Python-библиотеках, и пример
#* использования на Python.

#todo Все функции, которые реализуют параметрические тесты в библиотеках Python:

#* на вход принимают:
#* выборки или их параметры;
#* параметры проверяемой гипотезы;

#* на выход отдают:
#* уровень значимости p (p-value);
#* дополнительные параметры (в большинстве случаев они нам не нужны).

#* Предполагается, что в примерах из этого юнита все данные распределены нормально. Мы не будем проверять
#* нормальность распределения до проведения теста в целях экономии времени и количества кода. Однако в
#* реальных задачах, чтобы сделать выбор теста, требуется сделать проверку на нормальность.

#? ОДНОВЫБОРОЧНЫЙ T-КРИТЕРИЙ

#todo  Одновыборочный t-критерий (t-test) используют, чтобы сравнить среднее значение признака с
#todo  его заданным значением.

#* Одновыборочный t-критерий реализован в функции ttest_1samp() в модуле stats библиотеки scipy.

#todo Основные входные параметры:

#* a — выборочные данные;
#* popmean — ожидаемое среднее значение признака;
#* alternative — вид альтернативной гипотезы:
#* ‘two-sided’ (двусторонняя, используется по умолчанию);
#* ‘less’ (левосторонняя);
#* ‘greater’ (правосторонняя).
#* Примеры задач, когда может понадобиться использование теста:

#* Необходимо проверить, что среднее время, которое пользователи проводят на сайте, больше 5 минут.
#* Необходимо установить, соответствуют ли химические показатели товара заявленным на упаковке.

#todo ПРИМЕР ИСПОЛЬЗОВАНИЯ НА PYTHON

БИЗНЕС-ЗАДАЧА

#* Компания закупает батареи для своих устройств у определённого производителя. Раньше батареи работали
#* 40 часов. Производитель утверждает, что батареи были улучшены и теперь работают дольше.

#* Компания хочет проверить, правда ли, что батареи работают больше 40 часов. Для этого случайным
#* образом выбрали 20 батарей, замерили время их работы и получили следующие данные
#* в часах: 41, 38, 40, 46, 40, 46, 41, 44, 43, 39, 36, 41, 37, 45, 38, 45, 38, 48, 42, 34.

#* Уровень значимости необходимо взять равным 0.05.

import scipy.stats as stats

# задаём уровень значимости
alpha = 0.05 

# загружаем данные
data = [41, 38, 40, 46, 40, 46, 41, 44, 43, 39, 36, 41, 37, 45, 38, 45, 38, 48, 42, 34]

# проводим тест
_, p = stats.ttest_1samp(data, popmean=40, alternative='greater')

print('p-value = {:.3f}'.format(p))

# интерпретируем результат
if p <= alpha:
    print('p-значение меньше, чем заданный уровень значимости {:.2f}. Отвергаем нулевую гипотезу.'.format(alpha))
else:
    print('p-значение больше, чем заданный уровень значимости {:.2f}. У нас нет оснований отвергнуть нулевую гипотезу.'.format(alpha))

# p-value = 0.103
# p-значение больше, чем заданный уровень значимости 0.05. У нас нет оснований отвергнуть нулевую гипотезу.

#? ДВУХВЫБОРОЧНЫЙ T-КРИТЕРИЙ

#todo Двухвыборочный t-критерий (t-test) используют, чтобы сравнить средние значения в
#todo двух независимых группах.

#* Двухвыборочный t-критерий реализован в функции ttest_ind() в модуле stats библиотеки scipy.

#* Основные входные параметры:

#* a, b — выборочные данные двух групп;
#* alternative — вид альтернативной гипотезы:
#* ‘two-sided’ (двусторонняя, используется по умолчанию);
#* ‘less’ (левосторонняя);
#* ‘greater’ (правосторонняя);
#* equal_var — равны ли дисперсии в группах (по умолчанию равны).
#* Ограничения применения теста:

#* Группы должны быть независимыми.

#* Перед использованием необходимо установить равенство (или неравенство) дисперсий в выборках.
#* От этого зависит значение параметра equal_var.

#* Проверить равенство дисперсии в группах можно с помощью тестов Левена или Бартлетта,
#* которые реализованы в функциях levene() и bartlett() модуля stats библиотеки scipy:

#* Нулевая гипотеза обоих тестов утверждает, что дисперсии групп равны.
#* На вход функции получают выборочные данные.
#* На выход функции отдают p-значение

#todo Тест можно применять, только если данные в обеих выборках распределены нормально.

#* Проверку на нормальность нужно выполнить отдельно для каждой из двух групп. Если хотя бы в
#* одной группе распределение отличается от нормального, необходимо обратиться к непараметрическим тестам.

#todo ПРИМЕР ИСПОЛЬЗОВАНИЯ НА PYTHON

БИЗНЕС-ЗАДАЧА

#* Компания закупает для своих устройств батареи у производителя «Заряд». Производитель «Планета»
#* предлагает перейти на их батареи, утверждая, что они работают дольше. Компания хочет проверить,
#* правда ли, что батареи «Планета» работают дольше, чем батареи «Заряд».

#* Для этого случайным образом выбрали по 20 батарей «Заряд» и «Планета», замерили время их работы
#* и получили следующие данные в часах:

#* Батареи «Заряд»: 41, 38, 40, 46, 40, 46, 41, 44, 43, 39, 36, 41, 37, 45, 38, 45, 38, 48, 42, 34.

#* Батареи «Планета»: 40, 39, 42, 46, 41, 46, 42, 45, 44, 42, 38, 42, 38, 46, 39, 46, 40, 41, 43, 36.

#* Уровень значимости необходимо взять равным 0.05.

РЕШЕНИЕ

#* Сформулируем гипотезы в математическом виде:

#* Нулевая гипотеза: среднее время работы батарей «Планета» () меньше или равно среднему
#* времени работы батарей «Заряд» ().

#* Альтернативная гипотеза: среднее время работы батарей «Планета» () больше среднего времени
#* работы батарей «Заряд» ().

#todo Решение на Python:

import scipy.stats as stats
import numpy as np

# задаём уровень значимости
alpha = 0.05 

# загружаем данные
data_zaryad = np.array([41,38,40,46,40,46,41,44,43,39,36,41,37,45,38,45,38,48,42,34])
data_planeta = np.array([40,39,42,46,41,46,42,45,44,42,38,42,38,46,39,46,40,41,43,36])

# проводим тест Левена на равенство дисперсий
print('Тест на равенство дисперсий')
result = stats.levene(data_planeta, data_zaryad)
p = result[1]
print('p-value = {:.3f}'.format(p))

# интерпретируем результат
if p <= alpha:
    print('Дисперсии не одинаковы, в stats.ttest_ind нужно использовать параметр equal_var=False.')
else:
    print('Дисперсии одинаковы, в stats.ttest_ind нужно использовать параметр equal_var=True.')

# проводим тест на сравнение средних в группах
print('\nТест на равенство средних')
_, p = stats.ttest_ind(data_planeta, data_zaryad, alternative='greater', equal_var=True)

print('p-value = {:.3f}'.format(p))

# интерпретируем результат
if p <= alpha:
    print('p-значение меньше, чем заданный уровень значимости {:.2f}. Отвергаем нулевую гипотезу.'.format(alpha))
else:
    print('p-значение больше, чем заданный уровень значимости {:.2f}. У нас нет оснований отвергнуть нулевую гипотезу.'.format(alpha))

# Тест на равенство дисперсий
# p-value = 0.340
# Дисперсии одинаковы, в stats.ttest_ind нужно использовать параметр equal_var=True.

# Тест на равенство средних
# p-value = 0.260
# p-значение больше, чем заданный уровень значимости 0.05. У нас нет оснований отвергнуть нулевую гипотезу.

#todo Вывод: у нас нет оснований утверждать, что батареи «Планета» работают дольше, чем батареи «Заряд».

#* Обратите внимание, что порядок выборок в параметрах stats.ttest_ind важен: он должен соответствовать
#* альтернативной гипотезе.

#* Если бы в нашем примере мы перевернули альтернативную гипотезу,

#* Альтернативная гипотеза: среднее время работы батарей «Заряд» () меньше среднего
#* времени работы батарей «Планета» ():
    
#* , то параметры теста были бы такими (изменён порядок выборок и указано, что альтернативная гипотеза — 'less'):
_, p = stats.ttest_ind(data_zaryad, data_planeta, alternative='less', equal_var=True)

#? ОДНОФАКТОРНЫЙ ДИСПЕРСИОННЫЙ АНАЛИЗ (ANOVA)

#todo Однофакторный дисперсионный анализ (ANOVA) используют, чтобы сравнить средние значения
#todo в более чем двух независимых группах.

#* Тест ANOVA реализован в функции f_oneway() в модуле stats библиотеки scipy.

#* Основные входные параметры:

#* sample1, sample2, … — выборочные данные групп.
#todo Ограничения применения теста:

#* Группы должны быть независимыми.

#* Тест можно выполнять на группах с равной дисперсией.

#* Проверку равенства дисперсий также можно выполнить с помощью тестов Левена или Бартлетта.
#* Если дисперсии не равны, необходимо обратиться к непараметрическим тестам.

#* Тест можно применять, только если данные в обеих выборках распределены нормально.

#todo Проверку на нормальность нужно выполнить отдельно для каждой из двух групп. Если хотя бы в одной
#todo группе распределение отличается от нормального, необходимо обратиться к непараметрическим тестам.

#todo ПРИМЕР ИСПОЛЬЗОВАНИЯ НА PYTHON

БИЗНЕС-ЗАДАЧА

#* Компания закупает для своих устройств батареи у производителя «Заряд». Производители «Планета»
#* и «Энергия» предлагают перейти на их батареи, утверждая, что они работают дольше. Компания
#* хочет проверить, правда ли, что между батареями трёх производителей есть разница во времени работы.

#* Уровень значимости необходимо взять равным 0.05.

#* Случайным образом выбрали по 20 батарей «Заряд», «Планета» и «Энергия», замерили время их работы и получили следующие данные в часах:

#* Батареи «Заряд»: 31, 38, 30, 46, 40, 36, 38, 44, 43, 39, 36, 41, 37, 35, 38, 35, 38, 38, 42, 34.
#* Батареи «Планета»: 36, 45, 41, 41, 35, 32, 34, 42, 48, 43, 41, 39, 35, 34, 52, 42, 44, 43, 35, 43.
#* Батареи «Энергия»: 35, 37, 39, 49, 45, 26, 46, 32, 49, 41, 48, 41, 47, 37, 45, 41, 43, 38, 40, 43.

РЕШЕНИЕ

#* Сформулируем гипотезы в математическом виде:

#* Нулевая гипотеза: среднее время работы батарей «Заряд» (), «Планета» () и «Энергия» () одинаковое.

#* Альтернативная гипотеза: среднее время работы батарей «Заряд» (), «Планета» () и «Энергия» () не одинаковое.

#todo Решение на Python:

import scipy.stats as stats

# задаём уровень значимости
alpha = 0.05

# загружаем данные
group_zaryad = [31, 38, 30, 46, 40, 36, 38, 44, 43, 39, 36, 41, 37, 35, 38, 35, 38, 38, 42, 34]
group_planeta = [36, 45, 41, 41, 35, 32, 34, 42, 48, 43, 41, 39, 35, 34, 52, 42, 44, 43, 35, 43]
group_energiya = [35, 37, 39, 49, 45, 26, 46, 32, 49, 41, 48, 41, 47, 37, 45, 41, 43, 38, 40, 43]

# проводим тест Левена на равенство дисперсий
print('Тест на равенство дисперсий')
result = stats.levene(group_zaryad, group_planeta, group_energiya)
p = result[1]
print('p-value = {:.3f}'.format(p))

# интерпретируем результат
if p <= alpha:
    print('Дисперсии не одинаковы, нужно использовать непараметрический тест')
else:
    print('Дисперсии одинаковы, мы можем использовать тест ANOVA')

# проводим тест на сравнение средних в группах
print('\nТест на равенство средних')
_, p = stats.f_oneway(group_zaryad, group_planeta, group_energiya)

print('p-value = {:.3f}'.format(p))

# интерпретируем результат
if p <= alpha:
    print('p-значение меньше, чем заданный уровень значимости {:.2f}. Отвергаем нулевую гипотезу.'.format(alpha))
else:
    print('p-значение больше, чем заданный уровень значимости {:.2f}. У нас нет оснований отвергнуть нулевую гипотезу.'.format(alpha))

# Тест на равенство дисперсий
# p-value = 0.303
# Дисперсии одинаковы, мы можем использовать тест ANOVA

# Тест на равенство средних
# p-value = 0.141
# p-значение больше, чем заданный уровень значимости 0.05. У нас нет оснований отвергнуть нулевую гипотезу.

#todo Вывод: у нас нет оснований утверждать, что у батарей трёх производителей есть разница во времени работы.

#? ПАРНЫЙ T-КРИТЕРИЙ

#todo Парный t-критерий (t-test) используют, чтобы сравнить средние значения в двух зависимых группах.

#* Парный t-критерий реализован в функции ttest_rel() в модуле stats библиотеки scipy.

#* Основные входные параметры:

#* a, b — выборочные данные двух зависимых групп;
#* alternative — вид альтернативной гипотезы:
#* ‘two-sided’ (двусторонняя, используется по умолчанию);
#* ‘less’ (левосторонняя);
#* ‘greater’ (правосторонняя).
#* Ограничения применения теста:

#* Тест можно применять, только если данные в обеих выборках распределены нормально.
#* Проверку на нормальность нужно выполнить отдельно для каждой из двух групп.
#* Если хотя бы в одной группе распределение отличается от нормального, необходимо
#* обратиться к непараметрическим тестам.

#* Примеры задач, когда может понадобиться использование теста:

#* Требуется оценить эффективность нового лекарства, сравнивая показатели здоровья
#* (пульса / давления / уровня сахара в крови) одних и тех же пациентов до и после его применения.
#* Требуется оценить эффективность рекламной кампании, сравнивая показатели продаж до и после её запуска.

#todo БИЗНЕС-ЗАДАЧА

#* Компания закупает для своих устройств батареи у производителя «Заряд». Производитель «Планета»
#* предлагает перейти на их батареи, утверждая, что они работают дольше. Компания хочет проверить,
#* правда ли, что батареи «Планета» работают дольше, чем батареи «Заряд».

#* Уровень значимости необходимо взять равным 0.05.

#* При планировании эксперимента присутствовал эксперт, который сказал, что время работы батареи
#* зависит от устройства, на котором проходит замер, то есть результаты эксперимента оказались зависимыми.

#* Случайным образом выбрали по 20 батарей «Заряд» и «Планета». На каждом из устройств сначала
#* замерили время работы батареи одного производителя, затем — второго и получили следующие данные в часах:

#* Батареи «Заряд»: 1, 34, 35, 47, 39, 42, 36, 43, 48, 38, 36, 47, 39, 32, 45, 40, 36, 39, 42, 46.
#* Батареи «Планета»: 45, 42, 40, 43, 44, 41, 43, 39, 45, 45, 40, 43, 41, 42, 41, 41, 43, 46, 45, 42.

РЕШЕНИЕ

#* Сформулируем гипотезы в математическом виде:

#* Нулевая гипотеза: среднее время работы батарей «Планета» () меньше или равно среднему
#* времени работы батарей «Заряд» ().

#* Альтернативная гипотеза: среднее время работы батарей «Планета» () больше среднего времени
#* работы батарей «Заряд» ().

#todo Решение на Python:

import scipy.stats as stats
import numpy as np

# задаём уровень значимости
alpha = 0.05 

# загружаем данные
data_zaryad = np.array([41, 34, 35, 47, 39, 42, 36, 43, 48, 38, 36, 47, 39, 32, 45, 40, 36, 39, 42, 46])
data_planeta = np.array([45, 42, 40, 43, 44, 41, 43, 39, 45, 45, 40, 43, 41, 42, 41, 41, 43, 46, 45, 42])

# проводим тест
_, p = stats.ttest_rel(data_planeta, data_zaryad, alternative='greater')
print('p-value = {:.3f}'.format(p))

# интерпретируем результат
if p <= alpha:
    print('p-значение меньше, чем заданный уровень значимости {:.2f}. Отвергаем нулевую гипотезу.'.format(alpha))
else:
    print('p-значение больше, чем заданный уровень значимости {:.2f}. У нас нет оснований отвергнуть нулевую гипотезу.'.format(alpha))
# p-value = 0.023
# p-значение меньше, чем заданный уровень значимости 0.05. Отвергаем нулевую гипотезу.

#todo Вывод: батареи «Планета» работают дольше, чем батареи «Заряд».

#? ОДНОФАКТОРНЫЙ ДИСПЕРСИОННЫЙ АНАЛИЗ (ANOVA) С ПОВТОРНЫМИ ИЗМЕРЕНИЯМИ

#* Однофакторный дисперсионный анализ (ANOVA) с повторными измерениями используют, чтобы сравнить
#* средние значения в более чем двух зависимых группах.

#* Тест ANOVA с повторными измерениями реализован в функции AnovaRM() в модуле stats библиотеки statsmodels.

#* Основные входные параметры:

#* data — датафрейм с выборочными данными (три колонками: id группы, id объекта, значение признака);
#* within — название колонки с id группы;
#* subject — название колонки с id объекта;
#* depvar — название колонки со значением признака.

#todo Ограничения применения теста:

#* Тест можно применять, только если данные в обеих выборках распределены нормально.

#* Проверку на нормальность нужно выполнить отдельно для каждой из двух групп. Если хотя
#* бы в одной группе распределение отличается от нормального, необходимо обратиться к непараметрическим тестам.

#* Примеры задач, когда может понадобиться использование теста:

#* Требуется оценить эффективность нового лекарства, сравнивания показатели здоровья одних
#* и тех же пациентов до его приёма и через каждую неделю после начала приёма (количество периодов
#* — более двух).
#* Требуется изучать влияние нового рекламного материала на покупательское поведение клиентов
#* ежедневно на протяжении недели.

#todo ПРИМЕР ИСПОЛЬЗОВАНИЯ НА PYTHON

БИЗНЕС-ЗАДАЧА

#* Компания закупает для своих устройств батареи у производителя «Заряд». Производители «Планета»
#* и «Энергия» предлагают перейти на их батареи, утверждая, что они работают дольше. Компания хочет
#* проверить, правда ли, что между батареями трёх производителей есть разница во времени работы.

#* Уровень значимости необходимо взять равным 0.05.

#* При планировании эксперимента присутствовал эксперт, который сказал, что время работы батареи
#* зависит от устройства, на котором проходит замер.

#* Случайным образом выбрали по пять батарей «Заряд», «Планета» и «Энергия». На каждом из устройств
#* замерили время работы батареи одного производителя, затем — второго, затем — третьего и получили
#* следующие данные в часах:

#* Батареи «Заряд»: 36, 45, 41, 41, 35.
#* Батареи «Планета»: 32, 34, 42, 48, 43.
#* Батареи «Энергия»: 41, 39, 35, 34, 52.

#todo РЕШЕНИЕ

#* Сформулируем гипотезы в математическом виде:

#* Нулевая гипотеза: среднее время работы батарей «Заряд» (), «Планета» () и «Энергия» () одинаковое.

#* Альтернативная гипотеза: среднее время работы батарей «Заряд» (), «Планета» () и «Энергия» () не одинаковое.

#todo Решение на Python:

import numpy as np
import pandas as pd
from statsmodels.stats.anova import AnovaRM

# задаём уровень значимости
alpha = 0.05 

# создаём датасет
data = pd.DataFrame({'group': np.repeat(['Заряд', 'Планета', 'Энергия'], 5),
                          'object_id': np.tile([1, 2, 3, 4, 5], 3),                          
                          'value': [36, 45, 41, 41, 35, 32, 34, 42, 48, 43, 41, 39, 35, 34, 52]})


# проводим тест
print(AnovaRM(data=data, depvar='value', subject='object_id', within=['group']).fit())

#              Anova
# ==================================
#       F Value Num DF Den DF Pr > F
# ----------------------------------
# group  0.0100 2.0000 8.0000 0.9900
# ==================================

#todo Обратите внимание, что для использования теста необходимо вызвать метод fit(). Формат информации,
#todo который возвращает функция AnovaRM(), сильно отличается от ранее рассмотренных тестов: p-value
#todo отображается в колонке Pr > F.

#* В нашем примере p-значение равно 0.99. P-значение больше, чем заданный уровень значимости 0.05. Таким образом, у нас нет оснований отвергнуть нулевую гипотезу.

#todo Вывод: у нас нет оснований утверждать, что у батарей трёх производителей есть разница
#todo во времени работы.

#! Непараметрические тесты

#* Особенность непараметрических методов в том, что они сравнивают не сами значения признаков,
#* а их ранги или частоты.

#* В параметрических методах нулевые гипотезы содержали утверждения о равенстве средних значений признаков
#* в группах. В непараметрических тестах нулевые гипотезы будут о равенстве распределений признаков (что
#* включает в себя равенство средних) или о равенстве медиан признаков (в нормальных распределениях
#* медианы и средние равны).

#todo Все функции, которые реализуют непараметрические тесты в Python-библиотеках:

#* берут на вход:
#* выборки или их параметры;
#* параметры проверяемой гипотезы;
#* отдают на выход:
#* уровень значимости p (p-value);
#* дополнительные параметры.

#? ГИПОТЕЗЫ ДЛЯ ОДНОВЫБОРОЧНЫХ ТЕСТОВ