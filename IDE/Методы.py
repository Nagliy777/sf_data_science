
#? Строки

s = "Hello!"               Задаём строку
s[начало:конец:шаг]        Срез строки
s = "Hel" + “lo!"          Сложение строк
s = "Hello!"*n            Дублирование значения строки n раз

Длина строки len(s)                     
Метод для поиска подстроки в строке Пример вызова:  find(substr)             
возвращает индекс символа 'e' в строке s s.find('e')
Метод возвращает True, если строка состоит только из цифр isdigit()               
Метод возвращает True, если строка состоит только из букв isalpha()
Метод возвращает True, если строка состоит только из букв и цифр isalnum()
Метод возвращает новую строку в верхнем регистре upper()
Метод возвращает новую строку в нижнем регистре lower()
Метод разбивает строку на части по разделителю (по умолчанию — пробел)
 и возвращает результат в виде списка split(разделитель)
'строка-разделитель'.join(список)  Метод объединяет элементы списка в строку, 
                                     вставляя между ними строку-разделитель
f-строки          f'The {currency} currency rate on the date {cur_date} is {rate:.3f}'

#? Работа со списком

Вставка                a.append(“new_elem”)
Подсчёт                a.count(“new_elem”)
Копирование            b = a.copy()
Расширение             a.extend([“another”, “list”, “with”, “some”, “elements”])
Реверс                 a.reverse(), a[::-1]
Сортировка             a.sort()
Очистка                a.clear()


#? Кортеж
tpl1 = ()
tpl1 = tuple()
tpl1 = (1,2,3)
tpl1 = (1,)
tpl1 = ("hello", 4, 3.5, (1,2), [1,2,3], {"name": "Bob", "age": 33})

Кортежи — неизменяемые братья для списков. Можно использовать в ключах
для словаря

#? Словарь

dict1 = dict()
dict1 = {}
dict1 = {"name": "Bob", (1,2): 3, 3.5: [1,2,3]}

Взятие ключей dict1.keys()
Взятие значений dict1.values()

Обращение по ключу         dict1[“name”]
Метод .clear(), friends = {}   Очистка
Метод .get() Обращение по ключу с дефолтным значением
«Умная» замена обычному обращению по ключу через квадратные скобки. Если использовать только квадратные скобки при обращении 
к словарю, то при отсутствии нужного ключа программа выдаст ошибку и закончит работу.
В случае с .get() программа продолжит работать, но вернёт константу None — единственного представителя типа NoneType, 
который показывает, что значения нет, оно пусто.
Также .get() позволяет вывести значение по умолчанию для отсутствующего ключа. Это второй аргумент в методе .get():
#print(friends.get("Matvey", 'Netu')) -----> Netu
Метод .update() добавляет сразу несколько ключей и значений в словарь, а таже меняет существующее зачение.
#friends.update({'Tamara': 177, 'Bilbo':777, "Misha": 159})
Метод .pop() удаляет из структуры данных элементы, но дополнительно метод возвращает результат в новую переменную.
Метод .setdefault() принимает два параметра: ключ и значение по умолчанию, если этого ключа нет в словаре.
Если ключ имеется, его значение останется неизменным


#? Методы множеств

Метод .add() быстро и безболезненно добавить новый элемент в множество можно
#s = {1, 2, 3, 4}
#s.add(5)
#print(s) -----> {1, 2, 3, 4, 5}
Метод .update() добавляет во множество сразу несколько элементов.
#a = {1, 2, 3, 4}   Множество
#b = [5, 6, 7]      Список
#c = {'a':1, 'b':2} Словарь
#a.update(b)
#a.update(c)
#print(a) -----> {1, 2, 3, 4, 5, 6, 7, 'a', 'b'}
Методы .discard(), .remove() 
Их отличие друг от друга состоит в том,что при удалении уже отсутствующего элемента из множества discard() 
ничего не сделает, а вот .remove() выкинет ошибку.Суть выбора заключается в логике вашего алгоритма. 
Если вам важно, чтобы удаление элемента было явным, используйте метод .remove().
#s1 = {1,2,3,4,5}
#s1.remove(10)
#print(s1)  -----> KeyError: 10
#s1 = {1,2,3,4,5}
#s1.discard(10)
#print(s1)  -----> {1, 2, 3, 4, 5}
Метод .union() берёт все имеющиеся элементы в двух множествах ровно один раз. 
Порядок следования элементов может не соблюдаться.
#cluster1 = {"item1", "item2", "item3", "item4"}
#cluster2 = {"item2", "item3", "item5", "item7"}
#print(cluster1.union(cluster2)) -----> {'item3', 'item2', 'item7', 'item4', 'item1', 'item5'}

Метод .intersection() берутся все элементы, которые есть в обоих множествах.Ровно один раз.
#cluster1 = {"item1", "item2", "item3", "item4"}
#cluster2 = {"item2", "item3", "item5", "item7"}
#print(cluster1.intersection(cluster2)) -----> {'item3', 'item2'}

Метод .difference() выбирает все элементы из первого множества, которых нет во втором множестве.
#cluster1 = {"item1", "item2", "item3", "item4", "item5"}
#cluster2 = {"item3", "item4", "item5", "item6"}
#print(cluster1.difference(cluster2)) -----> {'item2', 'item1'}

Метод .issubset() используется для того, чтобы узнать, все ли элементы из первого множества есть во втором множестве.
#cluster1 = {"item1", "item2", "item3"}
#cluster2 = {"item2", "item3", "item4", "item5", "item6"}
#print(cluster1.issubset(cluster2)) -----> False

#? Логические операторы
not	        Логическое «НЕ»	Возвращает противоположное значение
or	        Логическое «ИЛИ»	Возвращает True, если хотя бы одна из переменных True
and	        Логическое «И»	Возвращает True, если обе переменные True
in, not in	Проверка принадлежности	Возвращает True, если проверяемая переменная содержится/не содержится в последовательности (списке, кортеже, строке...)
is, is not	Проверка тождественности	Возвращает True, если проверяемые объекты эквивалентны/не эквиваленты. То есть переменные ссылаются на один и тот же адрес в памяти компьютера
