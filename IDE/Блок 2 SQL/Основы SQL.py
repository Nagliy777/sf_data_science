
#? ЧТО ТАКОЕ БАЗЫ ДАННЫХ?

#*  База данных — это организованная структура для хранения, изменения и обработки взаимосвязанной информации.

#? ВИДЫ БАЗ ДАННЫХ

#*Базы данных можно разделить на два вида:

#* 1.Реляционные. В таких БД данные хранятся в виде связанных таблиц. В этом курсе мы сфокусируемся
#* именно на реляционных БД.
#* 2.Нереляционные. Такие БД имеют специфическую структуру: например, данные хранятся в формате ключ-значение
#* или в виде дерева.

#? ХРАНЕНИЕ ДАННЫХ В БД

#* Таблицы в БД состоят из строк и столбцов. Каждый столбец имеет своё уникальное название, которое
#* также отмечает вид хранимой в нём информации. В каждой строке хранится информация об одном объекте.

#* Таблица содержит определённое число столбцов, но может иметь любое количество строк.

#todo Для связи данных в разных таблицах часто используют ID — уникальный идентификатор какой-либо строки.
#todo Имя или какой-либо признак с этой целью не используются, поскольку они могут быть неуникальными.

#? СИСТЕМЫ УПРАВЛЕНИЯ БАЗАМИ ДАННЫХ

#* Данные мало хранить — с ними нужно работать: записывать, модифицировать и удалять. В этом помогает СУБД.

#* Система управления базами данных, или СУБД (от англ. DataBase Management System, DBMS) — это комплекс
#* программных средств, необходимых для создания структуры новой базы, её наполнения, редактирования
#* содержимого и отображения информации.

#* Существует множество СУБД, наиболее распространённые из них — MySQL, PostgreSQL, Oracle,
#* Microsoft SQL Server. Для очень большого объёма данных также используют ClickHouse, Hadoop и др.

#* Для работы с данными, хранящимися в БД, используется специальный язык — SQL,
#* который мы и будем изучать. Для работы с разными СУБД используются разные диалекты SQL.

#? Что такое SQL?

#* для взаимодействия с базами данных через СУБД часто используется язык SQL (Structured Query Language).
#* Он применяется для создания, модификации и управления данными.

#* С его помощью составляются запросы — своего рода вопросы, которые мы задаём, чтобы получить
#* некоторую информацию о данных, хранящихся в БД.

#todo SQL-запрос представляет собой совокупность операторов, инструкций, вычисляемых функций.

#? ВИДЫ ОПЕРАТОРОВ SQL

#todo Операторы SQL делятся на:

#* операторы определения данных (Data Definition Language, DDL) — с их помощью создаются и
#* изменяются объекты в БД (сама БД, таблицы, функции, процедуры, пользователи и т. д.);

#* операторы манипуляции данными (Data Manipulation Language, DML) — с их помощью проводятся
#* манипуляции с данными в таблицах;

#* операторы определения доступа к данным (Data Control Language, DCL) — с их помощью, как
#* следует из названия, создаются и изменяются разрешения на определённые операции с объектами в БД;

#* операторы управления транзакциями (Transaction Control Language, TCL) — с их помощью
#* осуществляется комплекс определённых действий, причём так, что либо все эти действия выполняются успешно, либо ни одно из них не выполняется вообще.

#todo Мы будем изучать только DML-операторы (для манипуляций с данными), а конкретнее — оператор SELECT,
#todo  который позволяет выбрать из БД интересующие нас данные.

#? Что такое Metabase?

#* Для написания запросов к БД необходим специальный инструмент. Это может быть терминал в ОС,
#* специализированная программа (например, одна из распространённых — DataGrip) или веб-сервис.
#* Именно такой веб-сервис мы будем использовать.

#! Основы SQL

#? Получаем все данные из таблицы

SELECT *
FROM sql.kinopoisk

#*  Оператор SELECT сообщает СУБД, что вы хотите извлечь из неё данные. SELECT лежит в основе
#* любого SQL-запроса к БД.

#*  FROM sql.kinopoisk сообщает, из какой таблицы извлекаются данные. Сначала указывается название
#* схемы, в которой содержится таблица (в нашем случае — это sql), а после точки — название самой таблицы (kinopoisk).

#* Звёздочка * указывает, что вы хотите видеть все столбцы этой таблицы.

#todo Если же вам нужны не все столбцы, а только некоторые, вместо звёздочки перечислите
#todo  названия всех интересующих вас столбцов через запятую.


#todo Metabase выводит только первые 2 000 строк: в нашем случае таблица полностью уместилась в выводе.

#* Допустим, вы хотите написать запрос, аналогичный запросу из задания, только вместо года выхода
#* фильма, вам нужен его «возраст» на 2020 год.

SELECT
    movie_title,
    2020 - year,
    rating
FROM sql.kinopoisk

#* То есть мы отняли от 2020 года год выхода фильма и получили его возраст! Элементарно!

#* Столбец с вычислениями в выводе называется ?column?, потому что Metabase не смог подобрать для него название.
#* Давайте наведём порядок и переименуем столбец!
#* Для этого используем ключевое слово AS и поставим после него новое имя difference.
#* Можем повторить этот процесс для каждого столбца.

SELECT
    director,
    movie_title,
    10 - rating AS difference
FROM sql.kinopoisk

#* Новое имя является просто псевдонимом, или алиасом, — оно временное и не меняет реального имени
#* столбца в базе данных. Алиас влияет только на то, как столбец отображается в выводе конкретного запроса.

#* Алиасом может быть как одно слово, так и несколько, а его написание — как латиницей, так и кириллицей.

#* Обратите внимание! Если в алиасе используются пробелы, необходимо заключать весь псевдоним
#* в двойные кавычки, например, movie_title AS "Movie Title".

#?  ПРОСТЫЕ ОПЕРАЦИИ С ДАННЫМИ

#* Со столбцами, которые содержат числовые данные, можно проводить арифметические операции:
#* +, -, *, /, получение остатка от деления с помощью %

#* Также мы можем проводить арифметические операции с несколькими столбцами.
#! Фильтруем строки

#? WHERE

#* Если мы хотим видеть не все строки, а только некоторые из них, то нам пригодится ключевое слово WHERE.

SELECT *
FROM sql.kinopoisk
WHERE position = 1


#todo Напишите запрос, чтобы вывести все столбцы для фильмов, которые вышли в прокат в 1999 году.
SELECT *
FROM sql.kinopoisk
WHERE year = 1999

#* Можно применять знаки < (меньше), <= (меньше или равно), > (больше), >= (больше или равно).

#todo Посмотрим на фильмы, которые вышли в прокат до 1984 года.
#todo При этом вы можете комбинировать вывод конкретных столбцов и условия.
SELECT
    position,
    movie_title,
    year,
    director
FROM sql.kinopoisk
WHERE year < 1984

#todo Выведем все столбцы для всех фильмов, кроме тех, что были сняты в 2000 году.
SELECT *
FROM sql.kinopoisk
WHERE year <> 2000

#? AND И OR

#todo Типичная ситуация: выбираем фильм на вечер. Мы хотим, чтобы фильм был
#todo относительно современным и с высоким рейтингом.

SELECT *
FROM sql.kinopoisk 
WHERE year >= 2000
AND rating >= 8

#todo Теперь вы хотите получить информацию о фильмах, которые вышли между 1975 и 1985 годами
#todo включительно. Можно воспользоваться следующим запросом:
SELECT *
FROM sql.kinopoisk
WHERE year >= 1975
    AND year <= 1985
    
#? BETWEEN

#* Можем оптимизировать запись, сделав более элегантной с помощью BETWEEN:
SELECT *
FROM sql.kinopoisk
WHERE year BETWEEN 1975 AND 1985

#* оператор фильтрует строки, которые находятся между двумя значениями.
#todo В PostgreSQL указанные значения включаются в интервал. В других СУБД BETWEEN может
#todo работать иначе и не включать указанные значения.

#todo Напишите запрос, который выведет столбцы с именем режиссёра и названием фильмов, у которых
#todo рейтинг больше или равен 8.5.

SELECT 
director,
movie_title
FROM sql.kinopoisk
WHERE 8.5 <= rating 

#todo Сколько в представленном списке фильмов, имеющих рейтинг от 8.7 до 8.8 включительно?
SELECT 
director,
movie_title
FROM sql.kinopoisk
WHERE rating BETWEEN 8.7 AND 8.8

#? NOT

#* В дополнение к другим операторам можно использовать ключевое слово NOT — оно
#* «переворачивает» следующий за ним оператор.

#todo Выведем все фильмы, кроме тех, что вышли с 1965 по 1980 годы.
SELECT *
FROM sql.kinopoisk
WHERE year NOT BETWEEN 1965 AND 1980

#* Если включаете в запрос несколько условий AND и OR, используйте скобки: они работают так же,
#* как и с арифметическими операциями. Важно! Условия в скобках имеют больший приоритет.

SELECT
    year,
    movie_title,
    director
FROM sql.kinopoisk
WHERE (rating > 8.5 AND year < 2000)
    OR year >= 2000
    
    
#? IN

#* Ещё один полезный оператор для фильтрации строк — IN.

#* Конструкции с IN имеют следующий вид:

#todo  column IN (value1, value2, value3)
#* Эта запись аналогична следующей: column = value1 OR column = value2 OR column = value3 
#* выглядит проще и компактнее.

#todo Напишите запрос, который выводит названия фильмов, вышедших в прокат в 2000, 1985 и 1939 годах.
SELECT
    movie_title
FROM sql.kinopoisk
where year IN (2000, 1985, 1939)

#todo До этого при работе с WHERE мы использовали только числа, но мы можем проводить
#todo  манипуляции и c данными типа текст. Давайте получим информацию о всех фильмах Леонида Гайдая
SELECT *
FROM sql.kinopoisk
WHERE director = 'Леонид Гайдай'

#todo в текстовых полях важен регистр.

#? LIKE

#* Например, чтобы получить все фильмы, название которых начинается на А (кириллическую),
#* мы воспользуемся таким запросом:
SELECT *
FROM sql.kinopoisk
WHERE movie_title LIKE 'А%'

#* Знак процента (%) в примере показывает, что после A встречается ноль и более символов.
#* Вы можете использовать % в любом месте внутри строки.

#todo Например, movie_title LIKE '%а%б%' выведет все фильмы, в названии которых
#todo встречается строчная буква а, а где-то после неё — б.

#* Также в текстовых строках используется знак подчёркивания (_) — он заменяет ровно один любой символ.

#* Напишите запрос, чтобы вывести название и год выпуска в прокат тех фильмов, которые были сняты
#* режиссёром по имени Дэвид (то есть значение в поле director начинается с 'Дэвид') и имеют
#* рейтинг больше 8.

SELECT 
movie_title,
year
FROM sql.kinopoisk
WHERE director LIKE 'Дэвид%' AND rating > 8

#? NULL

#* Вернёмся к просмотру всей таблицы с ТОП-250.
#* Вы можете заметить, что у некоторых строк заполнены не все столбцы.
#* Для пустых значений есть специальное обозначение — NULL.


#todo все фильмы, у которых в таблице отсутствует описание.
SELECT *
FROM sql.kinopoisk
WHERE overview is NULL

#todo NULL — это специальное значение. Если вы фильтруете столбец, в котором есть пустые значения,
#todo по любому условию, кроме IS NULL / IS NOT NULL, такие значения будут исключены из вывода.

#! Сортировка

#? ORDER BY

#* Порядок вывода строк может задаваться в настройках базы данных для каждой таблицы.
#* Более того, этот порядок может быть не задан, и тогда от вывода к выводу он будет разным.

#* Чтобы задать порядок вывода строк в запросе, применим новое ключевое слово ORDER BY.

#todo Для примера отсортируем фильмы по их названию в алфавитном порядке.

SELECT *
FROM sql.kinopoisk
ORDER BY movie_title

#todo Сортировка по возрастанию проводится по умолчанию.

#todo Наш запрос с сортировкой по названию аналогичен такому:
SELECT *
FROM sql.kinopoisk
ORDER BY rating ASC

#todo Для обратного порядка используется ключевое слово DESC (англ. descending).

#* Можно комбинировать в нашем запросе фильтрацию строк и сортировку вывода,
#* а также выводить только необходимые столбцы.

#todo Выведем названия, имена режиссёров и сценаристов, а также год выхода в прокат фильмов,
#todo выпущенных в СССР, и отсортируем результат по убыванию рейтинга.

SELECT
    movie_title,
    director,
    screenwriter,
    year
FROM sql.kinopoisk
WHERE country = 'СССР'
ORDER BY rating DESC

#todo Ключевое слово ORDER BY идёт после применения всех условий в WHERE.


#todo Напишите запрос, который выведет столбцы с названием фильма, его описанием и годом выхода в прокат.
#todo Оставьте только те фильмы, у которых рейтинг не ниже 8.2 и страна производства — не США. Отсортируйте
#todo вывод по году выхода фильма в порядке убывания.

SELECT 
movie_title,
overview,
year
FROM sql.kinopoisk
where rating >= 8.2 and country != 'США'
ORDER BY YEAR DESC

#todo Также в ORDER BY можно указывать, где должны идти пустые значения — в начале или в конце.
#todo Такая настройка порядка вывода задаётся с помощью ключевых слов NULLS FIRST / NULLS LAST.

SELECT
    movie_title,
    rating,
    overview,
    year
FROM sql.kinopoisk
ORDER BY overview NULLS FIRST

#* Такой запрос выведет первыми строки с пустым описанием.

#todo Можно сортировать вывод по нескольким столбцам, просто указав их через запятую в ORDER BY
#todo (порядок сортировки указывается отдельно для каждого столбца). Кроме того, вы можете сортировать результат
#todo запроса и по тем столбцам, которых нет в выводе.

#* Получили список всех режиссёров и фильмов из ТОП-250, отсортированных по году выхода в прокат,
#* а внутри года — по рейтингу в порядке убывания.

SELECT
    director,
    movie_title
FROM sql.kinopoisk
ORDER BY year, rating DESC


#todo Напишите запрос, чтобы вывести названия всех фильмов (столбец Название фильма), у которых рейтинг
#todo выше 8.3 и страна производства — Франция. Отсортируйте по рейтингу в порядке убывания,
#todo далее — по году выхода в прокат (также в порядке убывания).

SELECT
    movie_title
FROM sql.kinopoisk
where rating > 8.3 AND country = 'Франция'
ORDER BY rating, year DESC

#* Для упрощения работы с ORDER BY можно использовать не названия столбцов, а их номера из вывода.

SELECT
    director,
    movie_title,
    year
FROM sql.kinopoisk
ORDER BY 1, 3 DESC

#todo Сортировку по номеру столбца стоит использовать с осторожностью, поскольку при изменении вывода в SELECT
#todo всё может сбиться. При добавлении новых столбцов в SELECT нужно проверить и при необходимости поправить
#todo номера столбцов в ORDER BY.

#! Ограничение вывода

#? LIMIT

#* Ограничим вывод первыми десятью строками и сможем легко понять, какие данные хранятся
#* в таблице, не утяжеляя результат.
SELECT *
FROM sql.kinopoisk
LIMIT 10

#todo Выведем ТОП-5 фильмов по рейтингу, сначала отсортировав их по убыванию, а потом оставив только
#todo верхние пять строк с помощью LIMIT.

SELECT
    movie_title,
    rating
FROM sql.kinopoisk 
ORDER BY rating DESC
LIMIT 5

#todo Ключевое слово LIMIT используется в самом конце запроса!


SELECT 
director,
movie_title,
actors
FROM sql.kinopoisk
ORDER BY year
LIMIT 20

#todo Напишите запрос, который выводит информацию (Режиссёр, Название фильма и Актёры) по ТОП-20 самых
#todo старых (определяем по году выхода в прокат) фильмов из таблицы kinopoisk.

#? OFFSET

#todo Если LIMIT «оставляет» указанное число первых строк из вывода, то OFFSET, наоборот,
#todo «обрезает» указанное число первых строк.

#todo LIMIT и OFFSET можно использовать вместе, их порядок не важен.

#todo Выведем название и рейтинг фильмов с четвёртого по восьмое место.
SELECT
    movie_title,
    rating 
FROM sql.kinopoisk
ORDER BY rating DESC
OFFSET 3 LIMIT 5

#* Таким образом, LIMIT отсчитывает количество строк после указанной в OFFSET строки.



#todo Напишите запрос, чтобы вывести названия фильмов, которые вышли в прокат после 1990 года и были
#todo сняты не в России. Из этого списка оставьте только те фильмы, которые занимают с 20 по 47 места
#todo в рейтинге. Отсортируйте результат по убыванию рейтинга фильмов.

SELECT 
movie_title
FROM sql.kinopoisk
where year > 1990 and country != 'Россия'
ORDER BY rating DESC
OFFSET 19 LIMIT 28


#todo структура простого запроса:
SELECT
    столбец1 AS новое_название,
    столбец2,    столбец3
FROM таблица
WHERE (условие1 OR условие2)    AND условие3
ORDER BY сортировка1, сортировка2
OFFSET 1 LIMIT 2


#todo Напишите запрос, который выводит столбцы «Название фильма» (movie_title), «Режиссёр» (director),
#todo «Сценарист» (screenwriter), «Актёры» (actors). Оставьте только те фильмы, у которых:

#todo рейтинг между 8 и 8.5 (включительно) ИЛИ год выхода в прокат до 1990;
#todo есть описание;
#todo название начинается не с буквы 'Т';
#todo название состоит ровно из 12 символов.
#todo Оставьте только топ-7 фильмов, отсортированных по рейтингу.

SELECT 
movie_title AS "Название фильма",
director AS Режиссёр,
screenwriter AS Сценарист,
actors AS Актёры 
FROM sql.kinopoisk
WHERE ((rating BETWEEN 8 AND 8.5) OR (year < 1990)) AND (overview IS NOT NULL) AND (movie_title  NOT LIKE 'Т%') AND (movie_title LIKE '____________')
ORDER BY rating desc
LIMIT 7



