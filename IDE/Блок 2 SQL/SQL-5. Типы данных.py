
#? ОБЗОР ТИПОВ ДАННЫХ

#* При создании таблицы БД обязательно указывают типы данных, которые будут сохраняться в каждом
#* из её полей, — от этого зависит, какие значения допустимы в этих полях.

#? ОСНОВНЫЕ ТИПЫ ДАННЫХ В POSTGRESQL

#* SQL — это язык со строгой типизацией, в котором каждый элемент данных имеет некоторый тип,
#* определяющий его поведение и допустимое использование.

#todo Типы данных в PostgreSQL можно разделить на несколько групп. К основным относятся:

#todo 1.числовые типы — для хранения чисел (целых и дробных);
#todo 2.типы даты/времени — для хранения даты, времени, часовых поясов;
#todo 3.символьные типы — для хранения символов или строк;
#todo 4.логический тип — для хранения значений типа «истина», «ложь».

#todo В зависимости от требований к хранимой информации необходимо правильно применять типы данных.
#todo На это есть как минимум две причины.
#todo 1. Разные типы данных могут занимать разный объём памяти.
#todo 2. На преобразование типов данных тратится время.

#!  Даты: основные типы

#? TIMESTAMP

#* Timestamp — наиболее распространённый тип данных, так как он содержит и дату, и время,
#* а также используется в любых логах событий, временных рядах и в большинстве системных таблиц.

#todo Согласно стандарту ISO, значение выглядит как "2019-07-14 01:35:44.702165+00",
#todo где перечислены через точку год-месяц-день, время и часовой пояс.

#todo Для получения текущего значения даты и времени в Postgres используются функции CURRENT_TIMESTAMP

#* вы заметите, что время отличается на целое число часов от реального времени у вас (если вы не в
#* Лондоне или, скажем, на Канарских островах). В Москве разница составит 3 часа.

#? TIMESTAMP WITH TIME ZONE

#todo Timestamp with time zone позволяет хранить сведения о часовом поясе, что может быть удобно
#todo при анализе географически распределённых временных данных для единообразия хранения.

#* Предположим, в вашей компании в базу подтягивается время прихода сотрудников на работу. Вы пришли в
#* 10 утра по Москве, а в Екатеринбурге в это время — полдень. Чтобы ваши коллеги из Екатеринбурга поняли,
#* что вы пришли на работу вовремя, им нужно помнить про разницу в часовых поясах. А теперь представим,
#* что пользователи БД разбросаны по всему миру и всем им необходимо помнить о разнице во времени и
#* учитывать её при сверках с другими регионами.

#* Сначала попробуем узнать, в каком часовом поясе выводятся временные данные в настоящий момент.
#* Для этого выполните команду
#todo show timezone
#* В результате вы увидите GMT. Среднее время по Гринвичу 

#* Список часовых поясов можно увидеть в системном справочнике 
#todo select* from pg_timezone_names

#* посмотреть  время в каком-нибудь часовом поясе, например, в Москве. 
#todo select now() at time zone 'Europe/Moscow' as now

#? DATE

#* тип timestamp (with/without time zone) можно легко перевести в соответствующую дату, используя синтаксис
#todo "timestamp_column"::date

#* Для получения текущей даты можно использовать
#todo select CURRENT_DATE
#* или
#todo select now()::date


#todo Предположим, у нас есть дата и время какого-то события и мы хотим посмотреть, к какой дате оно
#todo относится для Москвы и для UTC.

with x as 
(
select '2018-12-31 21:00:00+00'::timestamp with time zone ts
)
select (ts at time zone ('Europe/Moscow'))::date as dt_msk,
(ts at time zone ('UTC'))::date as dt_utc
FROM x

#? INTERVAL

#* Interval — тип данных, позволяющий хранить разницу между двумя временными метками. 
#* Интервалы хранят данные в трёх отдельных полях — месяцах, днях, секундах. Это сделано из-за
#* того, что количество дней в месяце и часов в дне может быть разным. Пример значения такого
#* типа: "195 days -10:52:23.563955".

#! Функции и операторы для работы с датами

#? ФУНКЦИИ

#? Функция extract() получает из значений даты/времени такие поля, как год или час.

#* Для значений timestamp это день месяца (1-31), для значений interval — число дней.

SELECT EXTRACT(DAY FROM TIMESTAMP '2001-02-16 20:38:40');
# Результат: 16

SELECT EXTRACT(DAY FROM INTERVAL '40 days 1 minute');
# Результат: 40

#todo  HOUR Час (0-23).

SELECT EXTRACT(HOUR FROM TIMESTAMP '2001-02-16 20:38:40');
# Результат: 20



#todo  MONTH
#* Номер месяца, считая с января (1) до декабря (12).
SELECT EXTRACT(MONTH FROM TIMESTAMP '2001-02-16 20:38:40');
# Результат: 2



#todo YEAR
#* Поле года. Учтите, что года 0 не было, и это следует иметь в виду, вычитая из годов
#* нашей эры годы до нашей эры.
SELECT EXTRACT(YEAR FROM TIMESTAMP '2001-02-16 20:38:40');
#* Результат: 2001


#todo ISOYEAR 
#*  Год по недельному календарю ISO 8601, в который попадает дата (не применимо к интервалам).

SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-01');
# Результат: 2005

SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-02');
# Результат: 2006

#todo WEEK
#* Номер недели в году по недельному календарю ISO 8601. По определению, недели ISO 8601
#* начинаются с понедельника, а первая неделя года включает 4 января этого года. Другими словами,
#* первый четверг года всегда оказывается в первой неделе этого года.

#* В системе нумерации недель ISO первые числа января могут относиться к 52-й или 53-й неделе
#* предыдущего года, а последние числа декабря — к первой неделе следующего года.

#* Например, 2005-01-01 относится к 53-й неделе 2004 г., а 2006-01-01 — к 52-й неделе 2005 г.,
#*  тогда как 2012-12-31 включается в первую неделю 2013 г.

#* Поэтому для получения согласованных результатов рекомендуется использовать поле isoyear 
#* в паре с week.

SELECT EXTRACT(WEEK FROM TIMESTAMP '2001-02-16 20:38:40');
#* Результат: 7

#todo CENTURY
SELECT EXTRACT(CENTURY FROM TIMESTAMP '2000-12-16 12:21:13');
# Результат: 20

SELECT EXTRACT(CENTURY FROM TIMESTAMP '2001-02-16 20:38:40');
# Результат: 21

#* Первый век начался 0001-01-01 00:00:00, хотя люди в то время так и не считали.
#* Это определение распространяется на все страны с григорианским календарём.

#* Века с номером 0 не было; считается, что 1 наступил после -1.

#todo DECADE Десятилетие.

SELECT EXTRACT(DECADE FROM TIMESTAMP '2001-02-16 20:38:40');
# Результат: 200

#todo EPOCH

#* Для значений timestamp with time zone это число секунд с 1970-01-01 00:00:00 UTC (может быть
#* отрицательным); для значений date и timestamp это число секунд с 1970-01-01 00:00:00 по
#* местному времени, а для interval — общая длительность интервала в секундах.

SELECT EXTRACT(EPOCH FROM TIMESTAMP WITH TIME ZONE
'2001-02-16 20:38:40.12-08');
# Результат: 982384720.12

SELECT EXTRACT(EPOCH FROM INTERVAL '5 days 3 hours');
# Результат: 442800

#* Преобразовать время эпохи обратно, в значение дата/время, с помощью to_timestamp можно так:
SELECT to_timestamp(982384720.12);
# Результат: 2001-02-17 04:38:40.12+00

#todo DOW

#* День недели, считая с воскресенья (0) до субботы (6).

SELECT EXTRACT(DOW FROM TIMESTAMP '2001-02-16 20:38:40');
#Результат: 5

#* Заметьте, что в extract() дни недели нумеруются не так, как в функции to_char(..., 'D').

#todo DOY

#* День года (1-365/366).

SELECT EXTRACT(DOY FROM TIMESTAMP '2001-02-16 20:38:40');
# Результат: 47

#todo ISODOW

#* День недели, считая с понедельника (1) до воскресенья (7).

SELECT EXTRACT(ISODOW FROM TIMESTAMP '2001-02-18 20:38:40');
# Результат: 7

#* Результат отличается от dow только для воскресенья. Такая нумерация соответствует ISO 8601.

NOW()
CURDATE()
CURTIME()
SELECT DATEDIFF(CURDATE(), '28.02.2024');

#todo Пример
#* Давайте посчитаем помесячную статистику по доставкам, используя функцию extract. Напишите запрос,
#* который выведет год, месяц и количество доставок. Отсортируйте по году и по месяцу в порядке
#* возрастания. Столбцы в выдаче: year_n (номер года), month_n (номер месяца), qty (количество доставок).

SELECT
EXTRACT(YEAR FROM S.ship_date) AS year_n,
EXTRACT(MONTH FROM S.ship_date) AS month_n,
COUNT(ship_id) AS qty

FROM SQL.shipment S
GROUP BY year_n,month_n
ORDER BY year_n, month_n 

#? ФУНКЦИЯ TO_CHAR()

#todo Код форматирования	    Описание
#* HH24	                        час (00-23)
#* MI	                        минута (00-59)
#* SS	                        секунда (00-59)
#* MS	                        миллисекунда (000-999)
#* SSSS	                       число секунд с начала суток (0-86399)
#* YYYY	                        год (4 или более цифр)
#* YY	                    последние две цифры года
#* month	                полное название месяца в нижнем регистре (дополненное пробелами до девяти символов)
#* MM	                    номер месяца (01-12)
#* day	                    полное название дня недели в нижнем регистре, дополненное пробелами до девяти символов
#* DDD	                    номер дня в году (001-366)
#* DD	                    день месяца (01-31)
#* ID	                    номер дня недели по ISO 8601, считая с понедельника (1) до воскресенья (7)
#* WW	                    номер недели в году (1-53); первая неделя начинается в первый день года


#todo Пример
#* Предположим, мы хотим вывести сегодняшнюю дату в формате "Hello! Today is #название дня
#* недели год.название месяца.день#" текстом. Для этого нужно выполнить следующий код: 

select to_char(now(),'"Hello! Today is" DAY yyyy-Mon-dd')

#todo Пример

#* Давайте выведем текст текущего времени для сервиса точного времени. Напишите запрос, который
#* выводит текст "Точное время x часов y минут z секунд", при условии, что сообщение нужно вывести 
#* для московского часового пояса. Время введите в 24-часовом формате. Столбцы в выдаче: msg (сообщение).

select to_char(now() at time zone 'Europe/Moscow','Точное время HH24 часов MI минут SS секунд') AS msg

#? ФУНКЦИЯ DATE_TRUNC()

#* Функция date_trunc() позволяет отсечь заданное время, дату или дату со временем до нужной точности.
#* Формат вызова:
date_trunc('поле', значение)

#* Например, если мы хотим округлить текущее время-дату до минут, то можно вызвать
select date_trunc('minute',now())

#todo Для получения разной степени точности вместо minute можно использовать следующие параметры:

#* microseconds;  month;
#* milliseconds;  quarter; 
#* second;        year;
#* minute;        decade;
#* hour;          century;
#* day;           millennium.
#* week;


#todo Пример
#* Давайте подготовим данные для квартальной отчётности компании. Напишите запрос, который выведет
#* дату доставки, округлённую до квартала, и общую массу доставок. Отсортируйте по кварталу в порядке
#* возрастания. Столбцы в выдаче: q (начало квартала, тип date), total_weight (сумма масс доставок за квартал).

select 
date_trunc('quarter', ship_date)::date::text as q,
SUM(weight) as total_weight

FROM SQL.shipment AS S
GROUP BY q
order by q

#? МАТЕМАТИЧЕСКИЕ ОПЕРАТОРЫ

#todo К любой дате можно прибавить (и вычесть из неё) целое число X и получить другую дату,
#todo  которая больше (меньше) изначальной.

#todo Пример:

select '2019-01-01'::date + 10
# Результат: '2019-01-11' 
#* Это — дата на 10 дней позже 2019-01-01.

#* При добавлении (или вычитании) целого числа к дате Postgres учитывает переходы между месяцами и
#* годами и даёт верный ответ, соответствующий календарю. Учитываются даже високосные годы.

#todo Пример:

select '2019-01-01'::date + 500
# Результат: '2020-05-15'

#* Как видим, сменились и год, и месяц, и день.

#* Аналогично можно вычесть из одной даты другую и получить расстояние в днях между этими датами.
#* При такой операции тоже будет честная разница по календарю.

#todo Пример:

select '2019-02-10'::date - '2017-03-01'::date
# Результат: 711

#todo Пример:
#* Давайте оценим, в каком интервале совершались доставки в разных городах. Напишите запрос,
#* который выведет разницу между последним и первым днём доставки по каждому городу. Отсортируйте
#* по первому и второму столбцам. Столбцы в выдаче: city_name (название города) и days_active
#* (время от первой до последней доставки в днях).

select 
c.city_name,
max(s.ship_date) - min(s.ship_date) as days_active

FROM sql.shipment as s
    join sql.city as c on s.city_id = c.city_id
    
group by c.city_name

order by 1

#! Строковые данные: основные типы

#* В Postgres есть три основных типа данных для работы со строками: character, character varying и text.
#todo CHARACTER
#* Cтрока фиксированной длины, дополненная пробелами. Длина строки такого типа всегда одинакова и задаётся в скобках.

#* Например, в столбце character(5) всегда будет пять символов: строку большей длины туда вставить
#* не получится, а строка меньшей длины будет дополняться ведущими пробелами. Слово "SQL" в таком
#* столбце будет выглядеть как "  SQL". 
#* Основной паттерн использования такого типа — универсальные справочники буквенных кодов,
#* например код страны в стандарте ISO (RU, US, UK и т. д.).

#todo CHARACTER VARYING
#* Строка ограниченной переменной длины.
#* Например, в столбце типа character varying(5) нельзя будет хранить строку большей длины,
#* но могут быть любые строки с меньшей длиной.
#* Этот тип данных повсеместно используется для хранения данных, поскольку позволяет ограничить ввод,
#* сохраняя при этом возможность иметь строки произвольной длины.

#todo TEXT
#* Cтрока неограниченной длины.Самый удобный тип для пользователя, но самый
#* тяжеловесный для администратора баз данных, так как в строку можно записать любой текст.

#! Функции и операторы для работы со строками

#? ОПЕРАТОРЫ
#todo СОЕДИНЕНИЕ СТРОК
#* Конструкции с оператором соединения строк записываются следующим образом:

#* строка1 || строка2 || ... || строкаN

#* Результатом соединения любых типов строковых данных будет тип text.

#todo Пример 
#* Напишем запрос, который позволит подготовить простые select-запросы для всех таблиц из схемы.

select 'select * from '||t.table_schema||'.'||t.table_name||';' query
from information_schema.tables t
where table_schema = 'shipping'

#* В результате должно получиться пять SQL-запросов, по одному к каждой таблице из схемы shipping. 
#* Соединять можно и рукописный текст, и значения столбцов в любом произвольном порядке.

#todo Если вы соединяете любую строку и NULL, то результатом будет NULL. Поэтому,
#todo если вы формируете какой-то текст на основе поля, в котором присутствует NULL,
#todo используйте оператор coalesce.


#todo Пример
select
'Ваш заказ доставит водитель '||d.first_name||' '||last_name||'. Его контактный номер:'||' '||d.phone as msg
from sql.driver as d
where d.phone is not null

union

select
'Ваш заказ доставит водитель '||d.first_name||' '||last_name||'. Его контактный номер:'|| ' -'
from sql.driver as d
where d.phone is null

#? ФУНКЦИИ
#todo UPPER() И LOWER()
#* Функции upper(your_text) и lower(your_text) переводят каждый символ вашего текста в верхний
#* и нижний регистр соответственно.
#todo Пример:
select upper('Abc') as s1 ,lower('xYz') as s2


#todo Пример:
select
cus.cust_id as "id клиента",
lower(cust_name) as "название клиента в нижнем регистре"

from sql.customer as cus
     JOIN sql.shipment as s on cus.cust_id = s.cust_id
group by cus.cust_id
having count(ship_id) > 10

order by "id клиента"


#? REPLACE()
#* С помощью функции replace() можно заменять символы в строках.

#* Запись строится следующим образом:
replace(string text, from text, to text)

#todo Пример:
select replace('малако','а','о')
# молоко
select replace('машина','шина','трас')
# матрас

#* Если вы хотите удалить из строки какие-то символы, то третьим параметром (to) передайте
#* пустую строку ''(одинарные кавычки без символа внутри).
#* Например, сделаем из строки "Hello, world!" строку "Hello!".

select replace('Hello, world!',', world','')

#todo Пример:
select
replace(lower(state)||'__'||lower(city_name), ' ', '_') as utm


from sql.city as c

#? LEFT() И RIGHT()

#* Функции left(string,n) и right(string,n) оставляют n левых или правых символов от строки,
#* поданной на вход. Давайте разобьём строку 'Один два три' на слова, используя эти функции.

#todo Пример:
with t as
(
select 'Один два три'::text sample_string
)
select 
 left(t.sample_string,4) one, /*берём 4 левых символа строки*/
 right(left(t.sample_string,8),3) two, /*берём 8 левых символов строки, потом 3 правых от результата*/
 right(t.sample_string,3) three /*берём 3 правых символа от строки*/
from t

#todo Пример:
select left('0123456789', - 2), right('0123456789', - 2)
# Результат: 01234567 и 23456789 (в первом случае — восемь символов с «отрезанными» 89 и
# во втором случае — восемь символов с «отрезанными» 01)

#todo Пример:
#* Представим, что к вам пришёл разработчик, который хочет сократить поле state в таблице city до четырёх
#* символов, и попросил проверить, останeтся ли значения в нём уникальными. Чтобы ответить на этот вопрос,
#* напишите SQL-запрос, который выведет первые четыре символа названия штата и количество уникальных
#* названий штатов, которому они соответствуют. Оставьте только те, которые относятся к двум и более
#* штатам. Добавьте сортировку по первому столбцу. Столбцы в выдаче: code (четыре первых символа в
#* названии штата), qty (количество уникальных названий штата, начинающихся с этих символов).

select 
left(c.state, 4) as code,
count(distinct c.state) as qty

from sql.city as c
group by code
HAVING COUNT(distinct c.state)>=2
order by 1

#? FORMAT()
#* Функция format() используется для составления форматированного текста с подстановками. То же самое
#* можно сделать через конкатенацию строк, но это неудобно и громоздко.

#* Синтаксис функции выглядит следующим образом:

#todo format(formatstr text [, argument1 text,argument2 text...])

#* где formatstr — это шаблон, который мы передаём. Это обычная строка, в которой указаны
#* места для подстановки аргумента.

select format('Hello, %s!', d.first_name) from shipping.driver d
#* Комбинация символов %s обозначает, что вместо них будет подставлен один из аргументов,
#* причём в том же порядке, что и в исходном столбце.

#todo  Напишем запрос, который описывает содержимое каждой строки в таблице в виде текста.

select format('driver_id = %s, first_name = %s, last_name = %s, address = %s, zip_code = %s, phone = %s,
city_id = %s', driver_id, first_name, last_name, address, zip_code, phone, city_id)
from shipping.driver d

#* Мы перечислили в строке семь пропусков (плэйсхолдеров, или мест для подстановки, — %s),
#* передали семь параметров (все столбцы таблицы) и получили шаблон, заполненный значениями
#* для каждой строки.

#todo Если в вашем шаблоне присутствует одинарная кавычка, то для удобства можно
#todo вместо одинарных кавычек использовать $$ (два знака доллара):
select $$ some_string with quotes ' $$

#todo Пример:


select format($$%s is located in %s. There's %s people living there. Its area is %s$$, city_name, state, population, area) as str

FROM sql.city c

order by city_name


