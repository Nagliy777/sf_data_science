
#! СОЗДАНИЕ КОПИИ ТАБЛИЦЫ
Создадим копию melb_df с помощью метода copy():
melb_df = melb_data.copy()
melb_df.head()

#! УДАЛЕНИЕ СТОЛБЦОВ
Это может быть полезно, например, когда в данных есть признаки, которые не несут полезной информации.

За удаление строк и столбцов в таблице отвечает метод drop().
labels — порядковые номера или имена столбцов, которые подлежат удалению; если их несколько,
то передаётся список;

axis — ось совершения операции, axis=0 — удаляются строки, axis=1 — удаляются столбцы;

inplace — если параметр выставлен на True, происходит замена изначального DataFrame на новый,
при этом метод ничего не возвращает; если на False — возвращается копия DataFrame, из которой
удалены указанные строки (столбцы), при этом первоначальный DataFrame не изменяется; по умолчанию
параметр равен False.

Удалим столбцы index и Coordinates из таблицы с помощью метода drop(). 
Выведем первые пять строк таблицы и убедимся, что всё прошло успешно.
melb_df = melb_df.drop(['index', 'Coordinates'], axis=1)

Альтернативный вариант:
melb_df.drop(['index','Coordinates'],axis=1,inplace=True)

#! МАТЕМАТИЧЕСКИЕ ОПЕРАЦИИ СО СТОЛБЦАМИ

Все операции со столбцами совершаются поэлементно, очень быстро, а самое главное — без написания циклов.
total_rooms = melb_df['Rooms'] + melb_df['Bedroom'] + melb_df['Bathroom']
display(total_rooms)

А теперь введём признак MeanRoomsSquare, который соответствует средней площади одной комнаты
для каждого объекта. Для этого разделим площадь здания на полученное ранее общее количество комнат:
melb_df['MeanRoomsSquare'] = melb_df['BuildingArea'] / total_rooms
display(melb_df['MeanRoomsSquare'])

Можно ввести ещё один интересный признак — AreaRatio, коэффициент соотношения площади здания
(BuildingArea) и площади участка (Landsize). Для этого разницу двух площадей поделим на их сумму:
diff_area = melb_df['BuildingArea'] - melb_df['Landsize']
sum_area = melb_df['BuildingArea'] + melb_df['Landsize']
melb_df['AreaRatio'] = diff_area/sum_area    
    
#! ФОРМАТ DATETIME

Таким форматом в Pandas является формат datetime, который записывается как 
YYYY-MM-DD HH: MM: SS, то есть составляющие времени указываются в следующем порядке:
год, месяц, день, час, минута, секунда.

Для того чтобы преобразовывать столбцы с датами, записанными в распространённых форматах,
в формат datetime, можно воспользоваться функцией pandas.to_datetime(). В нашем случае
в функции нужно указать параметр dayfirst=True, который будет обозначать, что в первоначальном
признаке первым идет день. Преобразуем столбец Date в формат datetime, передав его в эту функцию:
melb_df['Date'] = pd.to_datetime(melb_df['Date'], dayfirst=True)

В результате мы переопределяем признак Date в формат datetime
Стоит обратить внимание, что изменился тип данных для столбца Date, теперь его тип — datetime64.
Рассмотрим несколько возможностей этого типа данных.

#! ВЫДЕЛЕНИЕ АТРИБУТОВ DATETIME

date — дата;
year, month, day — год, месяц, день;
time — время;
hour, minute, second — час, минута, секунда;
dayofweek — номер дня недели, от 0 до 6, где 0 — понедельник, 6 — воскресенье;
day_name — название дня недели;
dayofyear — порядковый день года;
quarter — квартал (интервал в три месяца).

Например, обратившись по атрибуту dt.year в столбце Date, мы можем «достать»
год продажи и понять, за какой интервал времени (в годах) представлены наши данные,
а также на какой год приходится наибольшее число продаж:
    
years_sold = melb_df['Date'].dt.year
print(years_sold)
print('Min year sold:', years_sold.min())
print('Max year sold:', years_sold.max())
print('Mode year sold:', years_sold.mode()[0])

В результате обращения к атрибуту datetime melb_df['Date'].dt.year мы получаем объект Series,
в котором в качестве значений выступают годы продажи объектов недвижимости. 

Теперь попробуем понять, на какие месяцы приходится пик продаж объектов недвижимости. Для этого
выделим атрибут dt.month и на этот раз занесём результат в столбец MonthSale, а затем
найдём относительную частоту продаж для каждого месяца от общего количества продаж — для этого
используем метод value_counts() с параметром normalize (вывод в долях):
melb_df['MonthSale'] = melb_df['Date'].dt.month
melb_df['MonthSale'].value_counts(normalize=True)

#! РАБОТА С ИНТЕРВАЛАМИ

Например, можно вычислить, сколько дней прошло с 1 января 2016 года до момента продажи объекта.
Для этого можно просто найти разницу между датами продаж и заявленной датой, представленной в формате datetime:
delta_days = melb_df['Date'] - pd.to_datetime('2016-01-01') 

В результате мы получаем Series, элементами которой является количество дней, 
которое прошло с 1 января 2016 года. Обратите внимание, что данные такого формата относятся к типу timedelta.
Чтобы превратить количество дней из формата интервала в формат целого числа дней,
можно воспользоваться аксессором dt для формата timedelta и извлечь из него атрибут days:
    
display(delta_days.dt.days)


Пример:
#* Напишите функцию get_weekend(weekday), которая принимает на вход элемент столбца WeekdaySale
#* и возвращает 1, если день является выходным, и 0 — в противном случае, и создайте столбец Weekend
#* в таблице melb_df с помощью неё.

def get_weekend(weekday):
    if weekday == 5 or weekday == 6:
        return 1
    else:
        return 0
    
    
#* Преобразуйте столбец SellerG с наименованиями риелторских компаний в таблице melb_df следующим образом:
#* оставьте в столбце только 49 самых популярных компаний, а остальные обозначьте как 'other'.
#* Найдите, во сколько раз минимальная цена объектов недвижимости, проданных компанией 'Nelson',
#* больше минимальной цены объектов, проданных компаниями, обозначенными как 'other'. Ответ
#* округлите до десятых.

popular_SellerG=melb_df['SellerG'].value_counts().nlargest(49).index
melb_df['SellerG'] = melb_df['SellerG'].apply(lambda x: x if x in popular_SellerG else 'other')
display(melb_df[melb_df['SellerG']=='Nelson']['Price'].min()/melb_df[melb_df['SellerG']=='other']['Price'].min())

#! ПРИЗНАКИ: КАТЕГОРИАЛЬНЫЕ И ЧИСЛОВЫЕ

#todo Рассмотрим такие статистические термины, как категориальные и числовые признаки.

#* Под числовыми признаками обычно подразумевают признаки, которые отражают количественную меру
#* и могут принимать значения из неограниченного диапазона.

#todo Числовые признаки могут быть:

дискретными (например, количество комнат, пациентов, дней);
непрерывными (например, масса, цена, площадь).
#* Дискретные признаки чаще всего представлены целыми числами, а непрерывные
#* — целыми числами и числами с плавающей точкой.

#todo Под категориальными признаками обычно подразумевают столбцы в таблице, которые
#todo обозначают принадлежность объекта к какому-то классу/категории.

#*Категориальные признаки могут быть:

номинальными (например, пол, национальность, район);
порядковыми (например, уровень образования, уровень комфорта, стадия заболевания).
#* Такие признаки имеют ограниченный набор значений. Они чаще всего представлены в виде
#* текстового описания и кодируются в Pandas типом данных object.

#! КАТЕГОРИИ В ДАННЫХ О НЕДВИЖИМОСТИ

#* Давайте определим число уникальных категорий в каждом столбце нашей таблицы melb_df. 
#* Для этого создадим вспомогательную таблицу unique_counts:

# создаём пустой список
unique_list = []
# пробегаемся по именам столбцов в таблице
for col in melb_df.columns:
    # создаём кортеж (имя столбца, число уникальных значений)
    item = (col, melb_df[col].nunique(),melb_df[col].dtypes)     # добавляем кортеж в список
    unique_list.append(item) 
# создаём вспомогательную таблицу и сортируем её
unique_counts = pd.DataFrame(
    unique_list,
    columns=['Column_Name', 'Num_Unique', 'Type']
).sort_values(by='Num_Unique',  ignore_index=True)
# выводим её на экран
display(unique_counts)

#! ТИП ДАННЫХ CATEGORY
#* Для хранения и оптимизации работы с категориальными признаками в Pandas предусмотрен
#* специальный тип данных — category.

#* этот тип данных расширяет возможности работы с категориальными признаками: мы можем легко
#* преобразовывать категории, строить графики по таким данным (что сложно сделать для типа данных object).
#* Также резко повышается производительность операций, совершаемых с такими столбцами.

#todo Самый простой способ преобразования столбцов к типу данных category — это использование уже
#todo знакомого нам метода astype(), в параметры которого достаточно передать строку 'category'.

#* Сделаем преобразование столбцов к типу данных category:
    
cols_to_exclude = ['Date', 'Rooms', 'Bedroom', 'Bathroom', 'Car'] # список столбцов, которые мы не берём во внимание
max_unique_count = 150 # задаём максимальное число уникальных категорий
for col in melb_df.columns: # цикл по именам столбцов
    if melb_df[col].nunique() < max_unique_count and col not in cols_to_exclude: # проверяем условие
        melb_df[col] = melb_df[col].astype('category') # преобразуем тип столбца
display(melb_df.info())

#! ПОЛУЧЕНИЕ АТРИБУТОВ CATEGORY

#* У типа данных category есть свой специальный аксесcор cat, который позволяет получать
#* информацию о своих значениях и преобразовывать их. Например, с помощью атрибута этого аксессора
#* categories мы можем получить список уникальных категорий в столбце Regionname:
print(melb_df['Regionname'].cat.categories)

#* А теперь посмотрим, каким образом столбец кодируется в виде чисел в памяти компьютера.
#* Для этого можно воспользоваться атрибутом codes:
display(melb_df['Regionname'].cat.codes)

#* С помощью метода аксессора rename_categories() можно легко переименовать текущие
#* значения категорий. Для этого в данный метод нужно передать словарь, ключи которого — 
#* старые имена категорий, а значения — новые.
#todo Рассмотрим на примере: переименуем категории признака типа постройки Type — заменим
#todo их на полные названия (напомним, u — unit, h — house, t — townhouse).
melb_df['Type'] = melb_df['Type'].cat.rename_categories({
    'u': 'unit',
    't': 'townhouse',
    'h': 'house'
})
display(melb_df['Type'])

#* тип данных category хранит только категории, которые были объявлены при его инициализации.
#* При встрече с новой, неизвестной ранее категорией, этот тип превратит её в пустое значение,
#* так как он просто не знает о существовании этой категории.

#todo Решить эту проблему на самом деле не сложно. Можно добавить категорию flat в столбец Type
#todo с помощью метода акссесора cat add_categories(), в который достаточно просто передать имя
#todo новой категории:
melb_df['Type'] = melb_df['Type'].cat.add_categories('flat')
new_houses_types = pd.Series(['unit', 'house', 'flat', 'flat', 'house'])
new_houses_types = new_houses_types.astype(melb_df['Type'].dtype)
display(new_houses_types)

#* Примечание. Добавление новой категории в столбец Type не отразится на самом столбце —
#* текущие категории не изменятся, однако такое преобразование позволит добавлять в таблицу
#* новые данные о домах с новой категорией — flat.

