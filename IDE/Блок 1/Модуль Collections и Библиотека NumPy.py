 Модуль Collections. Counter и defaultdict

#? Counter

#TODO Объект Counter (от англ. «счётчик») предназначен для решения часто возникающей задачи по подсчёту
#TODO различных элементов.

# Импортируем объект Counter из модуля collections
from collections import Counter
# Создаём пустой объект Counter
c = Counter()
cars = ['red', 'blue', 'black', 'black', 'black', 'red', 'blue', 'red', 'white']
c = Counter()
for car in cars:
    c[car] += 1 
   
 print(c) ---> Counter({'red': 3, 'black': 3, 'blue': 2, 'white': 1})
 
#TODO Однако гораздо проще при создании Counter сразу передать в круглых скобках итерируемый объект, 
#TODO в котором необходимо посчитать значения:

cars = ['red', 'blue', 'black', 'black', 'black', 'red', 'blue', 'red', 'white']
c = Counter(cars)
print(c) ---> Counter({'red': 3, 'black': 3, 'blue': 2, 'white': 1})

#TODO Узнать, сколько раз встретился конкретный элемент, можно, обратившись к счётчику по ключу 
#TODO как к обычному словарю:
print(c['black']) ---> 3

#TODO Если обратиться к счётчику по несуществующему ключу, то, в отличие от словаря, ошибка KeyError не возникнет:

print(c['purple']) ---> 0

#TODO Узнать сумму всех значений в объекте Counter можно, воспользовавшись следующей конструкцией:
print(sum(c.values())) ---> 9

#TODO Счётчики можно складывать и вычитать.
cars_moscow = ['black', 'black', 'white', 'black', 'black', 'white', 'yellow', 'yellow', 'yellow']
cars_spb = ['red', 'black', 'black', 'white', 'white', 'yellow', 'yellow', 'red', 'white']

counter_moscow = Counter(cars_moscow)
counter_spb = Counter(cars_spb) 
 
print(counter_moscow)  ---> Counter({'black': 4, 'yellow': 3, 'white': 2})
print(counter_spb) ---> Counter({'white': 3, 'red': 2, 'black': 2, 'yellow': 2})

print(counter_moscow + counter_spb) ---> Counter({'black': 6, 'white': 5, 'yellow': 5, 'red': 2})

#TODO Чтобы узнать разницу между объектами Counter, необходимо воспользоваться функцией subtract.
#TODO Функция subtract модифицирует исходный счётчик.
    
counter_moscow.subtract(counter_spb)
print(counter_moscow) --->  Counter({'black': 2, 'yellow': 1, 'white': -1, 'red': -2}) 

#TODO Чтобы получить список всех элементов, которые содержатся в Counter, используется функция elements().
#TODO Элементы возвращаются в порядке появления уникальных элементов. 

print(*counter_moscow.elements()) ---> black black black black white white yellow yellow yellow

#TODOЧтобы получить список уникальных элементов, достаточно воспользоваться функцией list():
     
print(list(counter_moscow)) ---> ['black', 'white', 'yellow']


#TODO С помощью функции dict() можно превратить Counter в обычный словарь:

print(dict(counter_moscow)) ---> {'black': 4, 'white': 2, 'yellow': 3}
    
#TODO Функция most_common() позволяет получить список из кортежей элементов в порядке убывания
#TODO их встречаемости:

print(counter_moscow.most_common()) ---> [('black', 4), ('yellow', 3), ('white', 2)]

#TODO В неё можно передать значение, которое задаёт число первых наиболее частых элементов, например, 2:

print(counter_moscow.most_common(2)) ---> [('black', 4), ('yellow', 3)]

#TODO Наконец, функция clear() позволяет полностью обнулить счётчик:
    
counter_moscow.clear()
print(counter_moscow) --->  Counter()

#? defaultdict
#TODO defaultdict не выдаёт ошибку при отсутствии ключа в словаре, 
#TODO а создаёт по запрошенному ключу объект по умолчанию;

#TODO Объект defaultdict из модуля collections. Он позволяет задавать тот тип данных, который хранится в словаре по умолчанию.

#TODO Создадим defaultdict, в котором при обращении по несуществующему ключу будет автоматически создаваться
#TODO новый список. Для этого при создании объекта defaultdict в круглых скобках передадим параметр list:
#TODO В скобках мы передаём именно указатель на класс объекта.
    
from collections import defaultdict
students = [('Ivanov',1),('Smirnov',4),('Petrov',3),('Kuznetsova',1),
            ('Nikitina',2),('Markov',3),('Pavlov',2)]

groups = defaultdict(list)

for student, group in students:
    groups[group].append(student)
 
print(groups) ---> defaultdict(<class 'list'>, {1: ['Ivanov', 'Kuznetsova'], 4: ['Smirnov'], 3: ['Petrov', 'Markov'], 2: ['Nikitina', 'Pavlov']})


#TODO Получить элемент из defaultdict по ключу можно так же, как и из обычного словаря:

print(groups[3]) ---> ['Petrov', 'Markov']

#TODO Если запрашиваемого ключа нет в словаре, KeyError не возникнет. 
#TODO Вместо этого будет напечатан пустой элемент, который создаётся в словаре по умолчанию:
print(groups[2021]) ---> []
#TODO Теперь в словаре groups автоматически появился элемент 2021 с пустым списком внутри, несмотря на то что мы его 
#TODO не создавали:
defaultdict(<class 'list'>, {1: ['Ivanov', 'Kuznetsova'], 4: ['Smirnov'], 3: ['Petrov', 'Markov'], 2: ['Nikitina', 'Pavlov'], 2021: []})


#?  OrderedDict.
#* Специальный словарь, который гарантирует сохранение ключей в порядке их добавления, называется OrderedDict:
#* В далёкие времена (а точнее, до 2018 года) словари в Python не сохраняли порядок ключей, которые в них добавляли. 
#* OrderedDict отвечает за сохранность порядка в словаре.Старые версии Python.

from collections import OrderedDict
data = [('Ivan', 19),('Mark', 25),('Andrey', 23),('Maria', 20)]
ordered_client_ages = OrderedDict(data)
print(ordered_client_ages) ---> OrderedDict([('Ivan', 19), ('Mark', 25), ('Andrey', 23), ('Maria', 20)])


data = [('Ivan', 19),('Mark', 25),('Andrey', 23),('Maria', 20)]
# Сортируем по второму значению из кортежа, то есть по возрасту
ordered_client_ages = OrderedDict(sorted(data, key=lambda x: x[1]))
print(ordered_client_ages) ---> OrderedDict([('Ivan', 19), ('Maria', 20), ('Andrey', 23), ('Mark', 25)])


#? deque

#*Очередь — это упорядоченный тип данных, который обладает двумя ключевыми функциями: добавление
#*элемента в конец очереди и извлечение самого первого элемента из очереди. 
#*То есть очередь подразумевает, что тот элемент, который первым добавлен в очередь, 
#*будет первым потом и обработан. Всё как в обычной очереди! 
#*Этот принцип сокращённо также называется FIFO (от англ. First In — First Out, «первым пришёл — первым ушёл»).

#*Стек (от англ. stack — стопка) — это упорядоченный тип данных, 
#*который обладает двумя основными функциями: добавление элемента в конец стека и извлечение 
#*элемента из конца стека. Эта структура данных также называется рюкзаком. Действительно, представьте себе,
#*что вы набили вещами рюкзак. Теперь, когда вы решите достать из него самую верхнюю вещь,
#*что это будет за вещь? Верно — та самая, которую вы убрали в рюкзак последней.
#*Поэтому принцип стека (рюкзака) также
#*сокращённо называется LIFO (Last In — First Out, «последним пришёл — первым ушёл»).

#* Cтруктура данных deque (читается как «дек», англ. double-ended queue — двухконцевая очередь).
#* Она объединяет в себе возможности и стека, и очереди: содержит функции,
#* которые позволяют добавлять элементы в начало или в конец очереди,
#* а также извлекать первый или последний элемент из неё. 

from collections import deque
dq = deque()
print(dq) ---> deque([])

#* У deque есть четыре ключевые функции:

#todo append (добавить элемент в конец дека);
#todo appendleft (добавить элемент в начало дека);
#todo pop (удалить и вернуть элемент из конца дека);
#todo popleft (удалить и вернуть элемент из начала дека).
#todo extend (добавить несколько элементов в конец дека).
#todo extendleft (добавить несколько элементов в начало дека).
#todo reverse (позволяет поменять порядок элементов в очереди на обратный)
#todo rotate (переносит  n заданных элементов из конца очереди в начало)

from collections import deque
clients = deque()
clients.append('Ivanov')
clients.append('Petrov')
clients.append('Smirnov')
clients.append('Tikhonova')
print(clients) ---> deque(['Ivanov', 'Petrov', 'Smirnov', 'Tikhonova'])

#* Объект deque поддерживает индексацию по элементам:
print(clients[2]) --->

#* Освободилось два оператора — заберём двоих человек из начала очереди с помощью popleft:

first_client = clients.popleft()
second_client = clients.popleft()
 
print("First client:", first_client)  ---> First client: Ivanov
print("Second client:", second_client) ---> Second client: Petrov
print(clients) ---> deque(['Smirnov', 'Tikhonova'])
 
#* Функции pop и popleft возвращают тот элемент, который они удаляют (последний или первый соответственно).

#*Добавить можо в начало очереди с помощью appendleft:

clients.appendleft('Vip-client')
print(clients) ---> deque(['Vip-client', 'Smirnov', 'Tikhonova'])

#* Последний клиент в очереди устал ждать и отменил вызов. Удалим его с помощью pop:
tired_client = clients.pop()
print(tired_client, "left the queue") ---> Tikhonova left the queue
print(clients) ---> deque(['Vip-client', 'Smirnov'])

#*С помощью pop всегда удаляется последний элемент из дэка. Чтобы удалить конкретный элемент по индексу,
#*необходимо воспользоваться встроенной конструкцией del:

clients = deque(['Ivanov', 'Petrov', 'Smirnov', 'Tikhonova'])
print(clients) ---> deque(['Ivanov', 'Petrov', 'Smirnov', 'Tikhonova'])

del clients[2]
print(clients) ---> deque(['Ivanov', 'Petrov', 'Tikhonova'])

#*Создадим очередь из клиентов магазинчика на заправке и добавим в неё сразу всех туристов, 
#*приехавших на экскурсионном автобусе, с помощью extend:

# В скобках передаём список при создании deque,
# чтобы сразу добавить все его элементы в очередь
shop = deque([1, 2, 3, 4, 5])
print(shop) ---> deque([1, 2, 3, 4, 5])

shop.extend([11, 12, 13, 14, 15, 16, 17])
print(shop) ---> deque([1, 2, 3, 4, 5, 11, 12, 13, 14, 15, 16, 17])

#* Если вдруг у турфирмы имеется договорённость с магазином, что клиенты турфирмы обслуживаются вне очереди,
#* добавим их в начало той же очереди с помощью extendleft:

shop = deque([1, 2, 3, 4, 5])
print(shop) ---> deque([1, 2, 3, 4, 5])

shop.extendleft([11, 12, 13, 14, 15, 16, 17])
print(shop) ---> deque([17, 16, 15, 14, 13, 12, 11, 1, 2, 3, 4, 5])


#? Очередь с ограниченной максимальной длиной
#* При создании очереди можно также указать её максимальную длину с помощью параметра maxlen.
limited_from_list = deque([1,3,4,5,6,7], maxlen=3)
print(limited_from_list) ---> deque([5, 6, 7], maxlen=3)

limited_from_list = deque([1,3,4,5,6,7], maxlen=3)
limited_from_list.append(8)
print(limited_from_list) ---> deque([6, 7, 8], maxlen=3)

#* Посчитаем динамику средней температуры с усреднением за каждые последние 7 дней для 
#* каждого рассматриваемого дня. Для этого воспользуемся очередью с параметром maxlen=7:
#*Такое преобразование называется скользящим средним. Оно позволяет сгладить колебания 
#* в данных и чётче увидеть тренд.

temps = [20.6, 19.4, 19.0, 19.0, 22.1,
        22.5, 22.8, 24.1, 25.6, 27.0,
        27.0, 25.6, 26.8, 27.3, 22.5,
        25.4, 24.4, 23.7, 23.6, 22.6,
        20.4, 17.9, 17.3, 17.3, 18.1,
        20.1, 22.2, 19.8, 21.3, 21.3,
        21.9]

days = deque(maxlen=7)
 
for temp in temps:
    # Добавляем температуру в очередь
    days.append(temp)
    # Если длина очереди оказалась равной максимальной длине очереди (7),
    # печатаем среднюю температуру за последние 7 дней
    if len(days) == days.maxlen:
        print(round(sum(days) / len(days), 2), end='; ')
# Напечатаем пустую строку, чтобы завершить действие параметра
# end. Иначе следующая строка окажется напечатанной на предыдущей
print("")

# Результат:
# 20.77; 21.27; 22.16; 23.3; 24.44; 24.94; 25.56; 26.2; 25.97;
# 25.94; 25.57; 25.1; 24.81; 24.21; 23.23; 22.57; 21.41; 20.4;
# 19.6; 19.1; 19.04; 18.96; 19.44; 20.01; 20.67;

reverse (позволяет поменять порядок элементов в очереди на обратный)
dq = deque([1,2,3,4,5])
dq.reverse()
print(dq) ---> deque([5, 4, 3, 2, 1])

rotate (переносит n заданных элементов из конца очереди в начало)
dq = deque([1,2,3,4,5])
dq.rotate(2)
print(dq) ---> deque([4, 5, 1, 2, 3])

#* Элементы можно переносить и из начала в конец:
dq = deque([1,2,3,4,5])
dq.rotate(-2)
print(dq) ---> deque([3, 4, 5, 1, 2])

#* Функция index позволяет найти первый индекс искомого элемента, а count позволяет подсчитать,
#* сколько раз элемент встретился в очереди (функции аналогичны одноимённым функциям для списков)
dq = [1,2,4,2,3,1,5,4,4,4,4,4,3]
print(dq.index(4)) ---> 2
print(dq.count(4)) ---> 6

#* Функция clear позволяет очистить очередь:
dq = deque([1,2,4,2,3,1,5,4,4,4,4,4,3])
dq.clear()
print(dq) ---> deque([])

#todo Решение задач

#* Напишите функцию check(temps), которая будет выводить словарь, в котором ключи — годы,
#* а значения — показатели температуры. Ключи необходимо отсортировать в порядке
#* убывания соответствующих им температур.

from collections import OrderedDict

temps =  [('2000', -4.4), ('2001', -2.5), ('2002', -4.4), ('2003', -9.5)]

def check(temps):
    temps.sort(key=lambda x: x[1], reverse=True)
    od = OrderedDict(temps)
    print(od)
    
print(check(temps)) ---> OrderedDict([('2001', -2.5), ('2000', -4.4), ('2002', -4.4), ('2003', -9.5)])

#Напишите функцию brackets(line), которая определяет, является ли последовательность из круглых 
#скобок правильной. Для решения этой задачи потребуется использовать стек.

from collections import deque
def brackets(line):
    de=deque()
    for i in line:
        if i == '(':
            de.append(i)
        elif i == ')':
            if len(de)==0:
                de.append(i)
            else:
                de.pop()
    
    if not de:
        return True
    else:
        return False
    
print(brackets(line = '(()())')) ---> True


#  Дан список кортежей ratings с рейтингами кафе. Кортеж состоит из названия и рейтинга кафе.
#  Необходимо отсортировать кортеж по убыванию рейтинга. Если рейтинги совпадают,
# то отсортировать кафе дополнительно по названию в алфавитном порядке.
# Получите словарь cafes с упорядоченными ключами из отсортированного списка, где ключи — названия кафе,
# а значения — их рейтинг.

ratings = [('Old York', 3.3), ('New Age', 4.6), ('Old Gold', 3.3), ('General Foods', 4.8),
           ('Belissimo', 4.5), ('CakeAndCoffee', 4.2), ('CakeOClock', 4.2), ('CakeTime', 4.1),
           ('WokToWork', 4.9), ('WokAndRice', 4.9), ('Old Wine Cellar', 3.3), ('Nice Cakes', 3.9)]

ratings.sort(key=lambda x: (-x[1],x[0]))


from collections import OrderedDict

cafes=OrderedDict(ratings)

# Напишите функцию task_manager, которая принимает список задач для нескольких серверов. 
# Каждый элемент списка состоит из кортежа (<номер задачи>, <название сервера>, <высокий приоритет задачи>).
# Функция должна создавать словарь и заполнять его задачами по следующему принципу: название сервера — ключ,
# по которому хранится очередь задач для конкретного сервера. 
# Если поступает задача без высокого приоритета (последний элемент кортежа — False), 
# добавить номер задачи в конец очереди. Если приоритет высокий, добавить номер в начало.
# Для словаря используйте defaultdict, для очереди — deque.
# Функция возвращает полученный словарь с задачами.

tasks = [(36871, 'office', False), (40690, 'office', False),
                  (35364, 'voltage', False), (41667, 'voltage', True), 
                  (33850, 'office', False)]

from collections import deque
from collections import defaultdict

def task_manager(tasks):
    test_dict=defaultdict(deque) 
    for i in tasks:
        if i[-1] is  True:
            test_dict[i[1]].appendleft(i[0])
        else:
            test_dict[i[1]].append(i[0])
    
           
    return test_dict   
    
    
print(task_manager(tasks)) ---> defaultdict(<class 'collections.deque'>, {'office': deque([36871, 40690, 33850]), 'voltage': deque([41667, 35364])})

#todo Модуль NumPy. Типы данных

#! N=2**n
#! где  n — число выделенных битов,  — максимально возможное при данном  число последовательностей,
#! N — оператор возведения в степень.

#*Сколько же чисел войдёт в 1 байт? 2 ** 8 = 256.Если мы захотим записать в байт целые
#*неотрицательные числа, мы сможем записать числа от 0 до 255 включительно.
#*Обратите внимание, число 256 вписать уже не получится, поскольку считать начали не с 1, а с 0.

#*От -128 до -1 содержится 128 целых чисел. От 1 до 127 ещё 127 чисел. Наконец, остаётся ноль — это 
#*ещё одно число. Итого получаем 128 + 127 + 1 = 256.

#! 8 бит = 1 байт
#* Чтобы узнать максимальное целое положительное число, которое можно уместить в  бит, 
#* необходимо воспользоваться следующей формулой:2**n-1
#* Например, в 16 бит поместится максимальное число 2 ** 16 - 1 = 65535, если считать минимальным числом 0.
#* Чтобы узнать минимальное и максимальное целое число существует две формулы:
#! N_min = -(2**n)/2
#! N_max = (2**n)/2-1

#? Целочисленные типы данных в NumPy.

#*Это тип данных с общим корнем int. Int может быть со следующими окончаниями:
#*int8, int16, int32 и int64. Окончание типа данных в NumPy показывает, сколько битов памяти должно
#*быть выделено для хранения переменной.

import numpy as np
a = np.int8(25)
print(a) ---> 25
print(type(a)) ---> <class 'numpy.int8'>

#* Чтобы узнать границы int, можно воспользоваться функцией np.iinfo (int info):

# Можно применить к самому
# названию типа данных
np.iinfo(np.int8)
# iinfo(min=-128, max=127, dtype=int8)

# Можно применить к существующему
# конкретному объекту
np.iinfo(a)
# iinfo(min=-128, max=127, dtype=int8)

#*В NumPy доступны и беззнаковые целочисленные типы данных. Они имеют корень uint 
#*(unsigned int — беззнаковое целое). uint доступны также с выделением памяти в 8, 16, 32 и 64 бита. 
#*При этом максимально возможное число оказывается в два раза больше, чем для соответствующего int, 
#*поскольку отрицательные числа исключены из типа данных uint.

b = np.uint8(124)
print(b)
# 124
print(type(b))
# <class 'numpy.uint8'>
np.iinfo(b)
# iinfo(min=0, max=255, dtype=uint8)

#* Если операция проводится с двумя NumPy-типами с фиксированным объёмом памяти,
#* в результате сохраняется наиболее «старший» тип:

a = np.int32(1000)
b = np.int8(25)
c = a + b
print(c) --->  1025
print(type(c)) ---> <class 'numpy.int32'>

#* Чтобы избежать этой ошибки, вначале следует преобразовать переменные к большему типу:

a = np.int32(2147483610)
b = np.int32(2147483605)
print(a, b) ---> 2147483610 2147483605
print(np.int64(a) + np.int64(b)) ---> 4294967215

#? ТИПЫ ДАННЫХ С ПЛАВАЮЩЕЙ ТОЧКОЙ В NUMPY
#* Доступны следующие типы данных float: float16, float32, float64 
#* (применяется по умолчанию, если объём памяти не задан дополнительно), float128.
#todo Если ввести в VS Code команду np.finfo(np.float128), ответом будет AttributeError: module 'numpy' 
#todo has no attribute 'float128'. Всё потому, что numpy.float128 не поддерживается в Windows с использованием
#todo компилятора MS. Если вам всё же нужно поработать с numpy.float128, воспользуйтесь онлайн-IDE.

#* Чтобы узнать границы float и его точность, можно воспользоваться функцией np.finfo(<float тип данных>) 
#* (от англ. float info):
np.finfo(np.float32)
# finfo(resolution=1e-06, min=-3.4028235e+38, max=3.4028235e+38, dtype=float32)

#* Например, 2021 можно записать в виде 2.021*10**3, При выводе числа в стандартном виде вместо умножения на 
#*1 0 в степени  пишется буква , знак степени (+ или -) и сама степень. 
#* Следовательно, число 2021 может быть представлено как 2.029e+3.
#*Т аким образом, минимальным значением float16 является -6.55040e+04, или -65504.0. 
#* Максимальное значение — 6.55040e+04, или 65504.0.

#?  Массивы

#* Массив — это структура данных, в которой:
#*1. Элементы хранятся в указанном порядке.
#*2. Каждый элемент можно получить по индексу за одинаковое время.
#*3. Все элементы приведены к одному и тому же типу данных.
#*4. Максимальное число элементов и объём выделенной памяти заданы заранее.

Создать массив из списка можно с помощью функции np.array(<объект>):

import numpy as np
arr = np.array([1,5,2,9,10])
print(arr) ---> array([ 1,  5,  2,  9, 10])
Функция np.array возвращает объекты типа numpy.ndarray:
print(type(arr)) ---> <class 'numpy.ndarray'>

# Перечислить список из списков можно
# было и в одну строку, но на нескольких
# строках получается нагляднее
nd_arr = np.array([
               [12, 45, 78],
               [34, 56, 13],
               [12, 98, 76]
               ])
print(nd_arr)
# array([[12, 45, 78],
#        [34, 56, 13],
#        [12, 98, 76]])

#todo ТИПЫ ДАННЫХ В МАССИВЕ

#* Задать тип данных сразу при создании массива можно с помощью параметра dtype:
arr = np.array([1,5,2,9,10], dtype=np.int8)
print(arr) ---> [ 1  5  2  9 10]
print(arr.dtype) ---> int8

#* При преобразовании типов данных в массиве не забывайте о том, 
#* что часть чисел может потерять смысл, если менять тип данных с более ёмкого на менее ёмкий:

arr = np.array([12321, -1234, 3435, -214, 100], dtype=np.int32)
print(arr) ---> array([12321, -1234,  3435,  -214,   100], dtype=int32)

#* Все числа, кроме 100, не могли быть корректно представлены в формате uint8.
arr = np.uint8(arr)
print(arr) ---> array([ 33,  46, 107,  42, 100], dtype=uint8)

#todo СВОЙСТВА NUMPY-МАССИВОВ 

arr = np.array([1,5,2,9,10], dtype=np.int8)
nd_arr = np.array([
               [12, 45, 78],
               [34, 56, 13],
               [12, 98, 76]
               ], dtype=np.int16)

#! Узнать размерность() массива можно с помощью .ndim:
print(arr.ndim) ---> 1
print(nd_arr.ndim) ---> 2

#* В самом деле, мы создали arr одномерным, а nd_arr — двумерным.

#!Узнать общее число элементов в массиве можно с помощью .size:
print(tarr.size) --->5
print(nd_arr.size) --->9

#! Форма или структура массива хранится в атрибуте .shape:
print(arr.shape) ---> (5,)
print(nd_arr.shape) ---> (3, 3)

#* Форма массива хранится в виде кортежа с числом элементов, равным размерности массива. 
#* Соответственно, для одномерного массива напечатан кортеж длины 1. Обратите внимание, 
#* что для двумерного массива вначале было напечатано число «строк», а затем число «столбцов».
#* Это так только отчасти. На самом деле массив как бы состоит из внешних и внутренних массивов:
#* вспомните, что мы передавали список, состоящий из трёх списков, длина каждого из которых равнялась трём.
#* Форма массива определяется от длины внешнего массива (3) к внутреннему (3).

#! Наконец, узнать, сколько «весит» каждый элемент массива в байтах позволяет .itemsize:
print(arr.itemsize) ---> 1
print(nd_arr.itemsize) ---> 2
#* В arr хранятся числа в виде int8 (8 бит => 1 байт), а в nd_arr — в виде int16 (16 бит => 2 байта).

#TODO ЗАПОЛНЕНИЕ НОВЫХ МАССИВОВ
#* Не всегда значения, которые будут храниться в массиве, уже доступны, а иметь для них массив уже хочется.
#* Массив из нулей создаётся функцией np.zeros. Она принимает аргументы shape (обязательный) —
#* форма массива (одно число или кортеж) и dtype (необязательный) — тип данных, 
#* который будет храниться в массиве.

#!Создадим одномерный массив из пяти элементов:
zeros_1d = np.zeros(5)
print(zeros_1d) ---> [0. 0. 0. 0. 0.]

#! Создадим трёхмерный массив с формой 5x4x3 и типом float32:

zeros_3d = np.zeros((5,4,3), dtype=np.float32)
print(zeros_3d.shape) ---> (5, 4, 3)

#! arange аналогична встроенной функции range, но обладает рядом особенностей. 
#! Вот её сигнатура: arange([start,] stop, [step,], dtype=None).
#*Аргументы start (по умолчанию 0), step (по умолчанию 1) и dtype (определяется автоматически).

#* start (входит в диапазон возвращаемых значений) задаёт начальное число;
#* stop (не входит в диапазон возвращаемых значений, как и при использовании range) задаёт правую границу диапазона;
#* step задаёт шаг, с которым в массив добавляются новые значения.
#* В отличие от range, в функции arange все перечисленные параметры могут иметь тип float.

print(np.arange(5)) ---> [0 1 2 3 4]

#!Создадим массив от 2.5 до 5:
print(np.arange(2.5, 5)) ---> ([2.5, 3.5, 4.5])

#!Создадим массив от 2.5 до 5 с шагом 0.5:
print(np.arange(2.5, 5, 0.5)) ---> ([2.5, 3. , 3.5, 4. , 4.5])

#!Создадим массив от 2.5 до 5 с шагом 0.5 и с типом float16:
a=np.arange(2.5, 5, 0.5, dtype=np.float16)
print(a) ---> [2.5 3.  3.5 4.  4.5]
print(a.dtype) ---> float16

#*Для работы с дробными параметрами start, stop и step лучше использовать функцию linspace 
#*(англ. linear space — линейное пространство). Она тоже возвращает одномерный массив из чисел,
#*расположенных на равном удалении друг от друга между началом и концом диапазона, но обладает немного 
#*другим поведением и сигнатурой:

np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)

#* start и stop являются обязательными параметрами, задающими начало и конец возвращаемого диапазона;
#* num — параметр, задающий число элементов, которое должно оказаться в массиве (по умолчанию 50);
#* endpoint — включён или исключён конец диапазона (по умолчанию включён);
#* retstep (по умолчанию False) позволяет указать, возвращать ли использованный шаг между значениями, помимо самого массива;
#* dtype — уже хорошо знакомый нам параметр, задающий тип данных (если не задан, определяется автоматически).

#!Давайте потренируемся. Создадим массив из десяти чисел между 1 и 2:

arr = np.linspace(1, 2, 10)
print(arr) --->
[1.         1.11111111 1.22222222 1.33333333 1.44444444 1.55555556
 1.66666667 1.77777778 1.88888889 2.        ]

#!Создадим массив из десяти чисел между 1 и 2, не включая 2:
arr = np.linspace(1, 2, 10, endpoint=False)
print(arr) ---> [1.  1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9]

#!Узнаем, какой шаг был использован для создания массива из десяти чисел между 1 и 2,
#!где 2 включалось и не включалось:

arr, step = np.linspace(1, 2, 10, endpoint=True, retstep=True)
print(step) ---> 0.1111111111111111
 

arr, step = np.linspace(1, 2, 10, endpoint=False, retstep=True)
print(step) --->  0.1

#* Функцию linspace очень удобно использовать при построении графиков различных функций,
#* поскольку она позволяет получить равномерный массив чисел, к которому можно применить
#* исследуемую функцию и показать результат на графике. Вы научитесь это делать в модуле,
#* посвящённом визуализации.

#TODO  ДЕЙСТВИЯ С МАССИВАМИ

#! Создадим массив из восьми чисел:

import numpy as np
arr = np.arange(8)
arr ---> ([0, 1, 2, 3, 4, 5, 6, 7])

#!Поменять форму массива arr можно с помощью присвоения атрибуту shape кортежа с желаемой формой.
#!Присвоение нового значения атрибуту shape изменяет тот массив, с которым производится действие:

arr.shape = (2, 4)
arr ---> ([[0, 1, 2, 3],
            [4, 5, 6, 7]])

#!Чтобы оставить исходный массив без изменений и дополнительно получить новый массив новой формы,
#!нужно использовать функцию reshape. 
arr = np.arange(8)
arr_new = arr.reshape((2, 4))
arr_new ---> ([[0, 1, 2, 3],
       [4, 5, 6, 7]])

#!У функции reshape есть дополнительный именованный аргумент order. Он задаёт принцип,
#!по которому элементы заполняют массив новой формы. Если order='C' (по умолчанию),массив заполняется
#!по строкам, как в примере выше. Если order='F', массив заполняется числами по столбцам:

arr = np.arange(8)
arr_new = arr.reshape((2, 4), order='F')
arr_new ---> ([[0, 2, 4, 6],
        [1, 3, 5, 7]])

#!Транспонирование меняет строки и столбцы массива местами. В NumPy эту операцию совершает функция transpose.

arr = np.arange(8)
arr.shape = (2, 4)
arr ---> ([[0, 1, 2, 3],
        [4, 5, 6, 7]])

#!Транспонируем его:

arr_trans = arr.transpose()
arr_trans ---> ([[0, 4],
                [1, 5],
                [2, 6],
                [3, 7]])
#* При транспонировании одномерного массива его форма не меняется.

#TODO ИНДЕКСЫ И СРЕЗЫ В МАССИВАХ 
arr = np.linspace(1, 2, 6)
arr ---> ([1. , 1.2, 1.4, 1.6, 1.8, 2. ])

#*Обратиться к его элементу по индексу можно так же, как и к списку:   
print(arr[2]) ---> 1.4 

#*Привычная запись для срезов работает и для одномерных массивов:
print(arr[2:4]) ---> [1.4 1.6]

#*Наконец, напечатать массив в обратном порядке можно с помощью привычной конструкции [::-1]:
print(arr[::-1]) ---> [2.  1.8 1.6 1.4 1.2 1. ]

#!С многомерными массивами работать немного интереснее. Создадим двумерный массив из одномерного:

nd_array =  np.linspace(0, 6, 12, endpoint=False).reshape(3,4)
nd_array ---> ([[0. , 0.5, 1. , 1.5],
                [2. , 2.5, 3. , 3.5],
                [4. , 4.5, 5. , 5.5]])
#*Можно воспользоваться привычной записью нескольких индексов в нескольких квадратных скобках:
nd_array[1, 2] ---> 3.0

#* Получим все элементы из колонки 3 для первых двух строк:
nd_array[:2, 2] ---> ([1., 3.])

#*Можно применять срезы сразу и к строкам, и к столбцам:
nd_array[1:, 2:4] ---> ([[3. , 3.5],
                         [5. , 5.5]])

#*Чтобы получить все значения из какой-то оси, можно оставить на её месте двоеточие.
#*Например, из всех строк получим срез с третьего по четвёртый столбцы:
nd_array[:, 2:4] ---> [[1.  1.5]
                       [3.  3.5]
                       [5.  5.5]]
    
#*Чтобы получить самую последнюю ось (в данном случае все столбцы), двоеточие писать необязательно. 
#*Строки будут получены целиком по умолчанию:
nd_array[:2] ---> [[0.  0.5 1.  1.5]
                   [2.  2.5 3.  3.5]]



#todo Задача:
import numpy as np


mystery = np.array([[-13586,  15203,  28445, -27117,  -1781, -17182, -18049],
       [ 25936, -30968,  -1297,  -4593,   6451,  15790,   7181],
       [ 13348,  28049,  28655,  -6012,  21762,  25397,   8225],
       [ 13240,   7994,  32592,  20149,  13754,  11795,   -564],
       [-21725,  -8681,  30305,  22260, -17918,  12578,  29943],
       [-16841, -25392, -17278,  11740,   5916,    -47, -32037]],
      dtype=np.int16)


#*1.В переменную elem_5_3 сохраните элемент из 5 строки и 3 столбца
elem_5_3=mystery[4,2]
#*2.В переменную last сохраните элемент из последней строки последнего столбца
last=mystery[-1,-1]
#*3.В переменную line_4 сохраните строку 4
line_4=mystery[3]
#*4.В переменную col_2 сохраните предпоследний столбец
col_2=mystery[:,-2]
#*5.Из строк 2-4 (включительно) получите столбцы 3-5 (включительно). Результат сохраните в переменную part
part=mystery[1:4,2:5]
#*6.Сохраните в переменную rev последний столбец в обратном порядке
rev = mystery[::-1, -1]
#*7.Сохраните в переменную trans транспонированный массив
trans=mystery.transpose()

#todo СОРТИРОВКА ОДНОМЕРНЫХ МАССИВОВ
#!Способ 1. Функция np.sort(<массив>) возвращает новый отсортированный массив:

arr = np.array([23,12,45,12,23,4,15,3])
arr_new = np.sort(arr)
print(arr_new) ---> [ 3  4 12 12 15 23 23 45]
#!Способ 2. Функция <массив>.sort()
arr = np.array([23,12,45,12,23,4,15,3])
arr.sort()
print(arr) ---> [ 3  4 12 12 15 23 23 45]

#todo РАБОТА С ПРОПУЩЕННЫМИ ДАННЫМИ
#*Начнём с примера — создадим массив:
data = np.array([4, 9, -4, 3])
#*Воспользуемся встроенной в NumPy функцией sqrt, чтобы посчитать квадратные корни из элементов.
roots = np.sqrt(data)
print(roots) ---> [2. 3. nan 1.73205081]

#*NumPy выдал предупреждение о том, что в функцию sqrt попало некорректное значение.
#*Где должен был оказаться корень из -4, теперь
#*присутствует объект nan. Он расшифровывается как Not a number (не число). Этот объект аналогичен
#*встроенному типу None, но имеет несколько отличий:
#!Отличие 1. None является отдельным объектом типа NoneType. np.nan — 
#!это отдельный представитель класса float:
print(type(None)) ---> <class 'NoneType'>
print(type(np.nan)) ---> <class 'float'>

#!Отличие 2. None могут быть равны друг другу, а np.nan — нет:
print(None == None) ---> True
print(np.nan == np.nan) ---> False
#* None даже через is не является эквивалентным np.nan:
print(None is None) ---> True
print(np.nan is np.nan) ---> True
print(np.nan is None) ---> False


#*Если попробовать посчитать сумму массива, который содержит np.nan, в итоге получится nan:
sum(roots) ---> nan
#*Можно заполнить пропущенные значения, например, нулями. Для этого с помощью
#*функции np.isnan(<массив>)узнаем, на каких местах в массиве находятся «не числа»:

data = np.array([4, 9, -4, 3])
roots = np.sqrt(data)
print(np.isnan(roots)) ---> [False False  True False]
print(roots[np.isnan(roots)]) ---> [nan]
roots[np.isnan(roots)] = 0   #* это тоже самое что [nan] = 0
print(roots)  ---> [2. 3. 0. 1.73205081]
print(sum(roots)) ---> 6.732050807568877 #* теперь сложилось без проблем.

#* Лаконично

data = np.array([4, 9, -4, 3])
roots = np.sqrt(data) #*sqrt квадратный корень из элементов
roots[np.isnan(roots)]=0 #* [nan] = 0
print(sum(roots)) ---> 6.732050807568877


#todo Задача:

import numpy as np


mystery = np.array([ 12279., -26024.,  28745.,  np.nan,  31244.,  -2365.,  -6974.,
        -9212., np.nan, -17722.,  16132.,  25933.,  np.nan, -16431.,
        29810.], dtype=np.float32)

#*Получите булевый массив nans_index с информацией о np.nan в массиве mystery: True - значение пропущено, 
#* False - значение не пропущено.
nans_index=np.isnan(mystery)
#*В переменную `n_nan сохраните число пропущенных значений
n_nan = len(mystery[nans_index])
#*Скопируйте массив mystery в массив mystery_new. Заполните пропущенные значения в массиве
#* mystery_new нулями
mystery_new=mystery
mystery_new[np.isnan(mystery_new)]=0
#*Поменяйте тип данных в массиве mystery на int32 и сохраните в переменную mystery_int
mystery_int = np.int32(mystery)
#*Отсортируйте значения в массиве по возрастанию и сохраните результат в переменную arra
array=np.sort(mystery)
#*Сохраните в массив table двухмерный массив, полученный из массива array. В нём должно быть 5 строк и 
#* 3 столбца. Причём порядок заполнения должен быть по столбцам!
table=array.reshape((5,3), order='F')
#*Сохраните в переменную col средний столбец из table
col=table[:,1]

#?  Операции с векторами

#*В программировании вектором называют одномерный проиндексированный набор данных,
#* другими словами — одномерный массив.
#*С векторами в NumPy можно производить арифметические операции: складывать, вычитать,
#*умножать друг на друга, возводить один вектор в степень другого и т. д.

#*При сложении двух векторов первым элементом нового вектора будет сумма первых элементов
#*исходных векторов, вторым — сумма вторых элементов и т. д.

#!Произведём сложение двух векторов:
import numpy as np
vec1 = np.array([2, 4, 7, 2.5])
vec2 = np.array([12, 6, 3.6, 13])
print(vec1 + vec2) ---> ([14. , 10. , 10.6, 15.5])

#!Поэлементно умножим два вектора одинаковой длины:

vec1 = np.array([2, 4, 7, 2.5])
vec2 = np.array([12, 6, 3.6, 13])
vec1 * vec2 ---> ([24. , 24. , 25.2, 32.5])

#*Количество элемнтов должно быть одинаковое.

#! Операции происходит с вектором и одним числом.
vec = np.arange(5)
vec * 10 ---> ([ 0, 10, 20, 30, 40])
vec ** 2 ---> ([ 0,  1,  4,  9, 16])

#! Также векторы можно сравнивать друг с другом поэлементно:

vec1 = np.array([2, 4, 7, 2.5])
vec2 = np.array([12, 6, 3.6, 13])
vec1 > vec2 ---> ([False, False,  True, False])

#!Аналогично можно сравнивать вектор с числом:
vec = np.array([14,15,9,26,53,5,89])
vec <= 26 ---> ([ True,  True,  True,  True, False,  True, False])

#TODO ПРОДВИНУТЫЕ ОПЕРАЦИИ С ВЕКТОРАМИ

#! Посчитаем длину следующего вектора:
vec = np.array([3, 4])
#*Для начала воспользуемся формулой: возведём все элементы в квадрат, посчитаем их сумму,
#*а затем найдём квадратный корень. Найдите все перечисленные операции в данном коде:
length = np.sqrt(np.sum(vec ** 2))
print(length) ---> 5.0

#*В NumPy есть специальный подмодуль linalg, который позволяет производить операции из линейной алгебры.

#!Для вычисления длины вектора нам потребуется функция norm:
length = np.linalg.norm(vec)
print(length) ---> 5.0

#*Реализуем вычисление расстояния между векторами в коде. Сначала — «сложным» способом напрямую из формулы:

vec1 = np.array([0, 3, 5])
vec2 = np.array([12, 4, 7])
distance = np.sqrt(np.sum((vec1 - vec2) ** 2))
distance ---> 12.206555615733702

#!вычисление расстояния между векторами с помощью функции np.linalg.norm:
vec1 = np.array([0, 3, 5])
vec2 = np.array([12, 4, 7])
distance = np.linalg.norm(vec1 - vec2)
distance ---> 12.206555615733702

#*Наконец, скалярным произведением двух векторов называют сумму произведений их соответствующих координат.
#*Вот формула для скалярного произведения векторов X и Y из n координат.Слово «скаляр» — синоним слова «число»

#!Реализуем это в коде (по-английски скалярное произведение называют dot — точечный — или scalar product,
#!отсюда и такое название переменной):
vec1 = np.arange(1, 6)
vec2 = np.linspace(10, 20, 5)
scalar_product = np.sum(vec1 * vec2)
scalar_product ---> 250.0

#!Проще и вообще без формул:
scalar_product = np.dot(vec1, vec2)
scalar_product ---> 250.0

#*Скалярное произведение также имеет широкое применение в математике и других операциях с векторами.
#*В частности, равенство скалярного произведения нулю означает перпендикулярность рассматриваемых векторов:
x = np.array([25, 0])
y = np.array([0, 10])
np.dot(x, y) ---> 0

#todo Задача
#* Векторы в геометрии называются сонаправленными, если они коллинеарны и их направления совпадают.
#*Отметим, что прямые, на которых лежат сонаправленные вектора, всегда по определению являются параллельными.
#*Поэтому есть несколько математических способов определить сонаправленность векторов. Один из них: 
#*сумма длин сонаправленных векторов должна быть равной длине суммы двух векторов.
#*С помощью этого критерия среди векторов a, b и c (которые приведены в файле выше) найдите пару сонаправленных векторов.

import numpy as np

a = np.array([23, 34, 27])
b = np.array([-54,   1,  46])
c = np.array([46, 68, 54])

a_length = np.linalg.norm(a)
b_length = np.linalg.norm(b)
c_length = np.linalg.norm(c)

a_b=a_length+b_length
b_c=b_length +c_length
a_c=a_length+c_length

o=np.linalg.norm(a+b)
p=np.linalg.norm(b+c)
i=np.linalg.norm(a+c)

print(a_b==o) ---> False
print(b_c==p) ---> False
print(a_c==i) ---> True

#todo Задача
#* Найдите пару векторов, расстояние между которыми больше 100.

import numpy as np

a = np.array([23, 34, 27])
b = np.array([-54,   1,  46])
c = np.array([46, 68, 54])

o=np.linalg.norm(a-b)
p=np.linalg.norm(b-c)
i=np.linalg.norm(a-c)

print(o) ---> 85.901105930017
print(p) ---> 120.6358155772986
print(i) ---> 49.13247398615299

#TODO БАЗОВЫЕ СТАТИСТИЧЕСКИЕ ФУНКЦИИ ДЛЯ ВЕКТОРОВ
#!Функции np.min и np.max позволяют находить максимальное и минимальное значение в векторе.
#!Их можно записывать как в виде np.min(<vector>), так и в виде <vector>.min():

vec = np.array([2,7,18,28,18,1,8,4])
vec.min() ---> 1
np.max(vec) --->28

#! Функция mean позволяет посчитать среднее значение. Больше не требуется реализовывать её «руками»!
vec.mean() --->


#? Случайные числа
#*Случайное число — это число, которое возникает в результате случайного процесса.

#TODO ГЕНЕРАЦИЯ FLOAT
#*Для генерации псевдослучайных чисел в NumPy существует подмодуль random.
#!Самой «базовой» функцией в нём можно считать функцию rand. По умолчанию она генерирует число
#!с плавающей точкой между 0 (включительно) и 1 (не включительно):

import numpy as np
np.random.rand() ---> 0.06600758835806675

#!Чтобы получить случайное число в диапазоне, например, от 0 до 100, достаточно просто умножить
#!генерируемое число на 100:
np.random.rand() * 100 ---> 69.76076924077643

#*rand умеет генерировать не только отдельные числа — функция принимает в качестве аргументов через
#*запятую целые числа, которые задают форму генерируемого массива. Например, получим массив из пяти
#*случайных чисел:
np.random.rand(5) ---> ([0.83745099, 0.58426808, 0.89206204, 0.41149807, 0.42445145])

#!Массив из двух случайных строк и трёх столбцов:
np.random.rand(2, 3) ---> ([[0.94931212, 0.06680018, 0.26707599],
                          [0.67908873, 0.18001743, 0.97732239]])

#!В NumPy есть функция, генерирующая массивы случайных чисел от 0 до 1,
#!которая принимает в качестве аргумента именно кортеж без распаковки. Она называется sample:
shape = (2, 3)
np.random.sample(shape) --->([[0.39756103, 0.01995168, 0.2768951 ],
                            [0.82195372, 0.26435273, 0.00957881]])  

#!Функция uniform. Получим пять чисел в интервале от 0.5 до 0.75:  
np.random.uniform(0.5, 0.75, size=5) ---> ([0.58078945, 0.58860342, 0.73790553, 0.63448265, 0.70920297])

#* Получим массив из двух строк и трёх столбцов из чисел в интервале от -1000 до 500:
np.random.uniform(-1000, 500, size=(2, 3)) ---> ([[ 129.22164163,   77.69090611, -132.9656972 ],
                                                  [  18.65802226, -317.14793906,   85.3613547 ]])
       
#todo ГЕНЕРАЦИЯ INT
#!Для генерации целых чисел используется функция random.randint:

randint(low, high=None, size=None, dtype=int)
#*Функцию randint нельзя запустить совсем без параметров, необходимо указать хотя бы одно число.
#*Если указан только аргумент low, числа будут генерироваться от 0 до low-1, то есть верхняя граница не включается.
#*Если задать low и high, числа будут генерироваться от low (включительно) до high (не включительно).
#*size задаёт форму массива уже привычным для вас образом: одним числом — для одномерного
#*или кортежем — для многомерного.
#*dtype позволяет задать конкретный тип данных, который должен быть использован в массиве.

#!Сгенерируем таблицу 2x3 от 0 до 3 включительно:
np.random.randint(4, size=(2,3))  ---> ([[3, 0, 1],
                                         [2, 1, 3]])
#!Чтобы задать и нижнюю, и верхнюю границы самостоятельно, передадим два числа, а затем форму:
np.random.randint(6, 12, size=(3,3))--->  ([[ 9,  6, 10],
                                            [10, 11, 10],
                                            [ 7, 10, 11]])    

#todo ГЕНЕРАЦИЯ ВЫБОРОК 
#!Просто перемешать все числа в массиве позволяет функция random.shuffle.

arr = np.arange(6)
print(arr) ---> [0 1 2 3 4 5]
np.random.shuffle(arr)
print(arr) ---> ([0, 5, 1, 3, 2, 4])

#!Чтобы получить новый перемешанный массив, а исходный оставить без изменений,
#!можно использовать функцию random.permutation.

playlist = ["The Beatles", "Pink Floyd", "ACDC", "Deep Purple"]
shuffled = np.random.permutation(playlist)
print(shuffled) ---> ['The Beatles' 'Pink Floyd' 'Deep Purple' 'ACDC']
print(playlist) ---> ['The Beatles', 'Pink Floyd', 'ACDC', 'Deep Purple']

#*Обратите внимание, что необязательно передавать в функцию сразу массив: в этот раз мы передали в
#*качестве аргумента список и ошибки не возникло. При этом на выходе получился уже NumPy-массив
#*(это заметно по отсутствию запятых при печати массива). Сам список playlist при этом остался без изменений.

#!Перемешать набор чисел от 0 до n-1 можно с помощью записи np.random.permutation(n),
#!где n — верхняя граница, которая бы использовалась для генерации набора чисел функцией arange.
np.random.permutation(10) ---> ([7, 8, 2, 9, 4, 3, 1, 0, 5, 6])

#!Чтобы получить случайный набор объектов из массива, используется функция random.choice:
#*Выбираем двух рандомных людей из списка
workers = ['Ivan', 'Nikita', 'Maria', 'John', 'Kate']
 
choice = np.random.choice(workers, size=2, replace=False)
print(choice) ---> ['John' 'Nikita']

#*Если попытаться получить без повторений массив большего размера, чем имеется объектов в исходном,
#*возникнет ошибка: Ошибка значения: нельзя получить выборку больше, чем популяция

#*Выборка с повторениями replace используется по умолчанию. Она применяется в том случае, когда мы допускаем,
#*что объекты могут повторяться.
#!В данном случае ошибка не возникает за счёт того, что объекты могут повторяться.
choice = np.random.choice([1,2,3,4,5,6], size=10)
print(choice) ---> [3 5 5 6 6 4 2 2 1 3]

#todo SEED ГЕНЕРАТОРА ПСЕВДОСЛУЧАЙНЫХ ЧИСЕЛ
#*Иногда бывает необходимо получать одинаковые воспроизводимые последовательности случайных чисел,
#*например чтобы проверить результаты вычислений, для которых использовались случайные числа,
#*на предмет ошибок.

#!Зададим seed и посмотрим, что получится:

np.random.seed(23)
np.random.randint(10, size=(3,4)) ---> ([[3, 6, 8, 9],
                                         [6, 8, 7, 9],
                                         [3, 6, 1, 2]])
#*Если запустить этот код на своём компьютере, то, скорее всего, увидите тот же самый набор чисел!  
#*При этом запуск одной и той же функции генерации случайных чисел несколько
#*раз после задания seed не приводит к генерации одних и тех же чисел. Однако итоговый результат
#*работы всегда будет одинаковый в совокупности.      


#todo Задача
import numpy as np

#* Задайте seed = 2021.
np.random.seed(2021)
#*В simple сохраните случайное число в диапазоне от 0 до 1
simple=np.random.rand()
#*Сгенерируйте 120 чисел в диапазоне от -150 до 2021, сохраните их в переменную randoms
randoms=np.random.uniform(-150,2021, size=120)
#*Получите массив из случайных целых чисел от 1 до 100 (включительно) из 3 строк
#*и 2 столбцов. Сохраните результат в table
table=np.random.randint(1,101,size=(3,2))
#*В переменную even сохраните четные числа от 2 до 16 (включительно)
even=np.arange(2,18,2)
#*Скопируйте even в переменную mix. Перемешайте числа в mix так, чтобы массив изменился
mix=np.random.permutation(even)
#*Получите из even 3 числа без повторений. Сохраните их в переменную select
select=np.random.choice(even, size=3, replace=False)
#*Получите переменную triplet, которая должна содержать перемешанные значения из
#* массива select (сам select измениться не должен)
triplet=np.random.permutation(select)                            

        

    
                   



