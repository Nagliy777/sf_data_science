
#TODO Модуль Collections

#? OrderedDict Гарантирует сохранение ключей в словаре в порядке добавления

from collections import OrderedDict
# Создание OrderedDict из списка
# кортежей формата (ключ, значение):
od = OrderedDict([('Ivan', 23),
('Nikita', 24), ('Elena',29),
('John',27), ('Gosha','22')])
# С версии Python 3.7 сохранение порядка
# ключей гарантируется и для обычных
# словарей

#? Deque. Возможности стека и очереди в одной структуре данных

from collections import deque
# Создание дэка из списка с макс. длиной
d = deque([1,2,3], maxlen=5)
# Добавление элемента справа и слева:
d.append(10); d.appendleft(4)
# Удаление элемента справа и слева:
print(d.pop(), d.popleft())
# 10 4
# Добавление нескольких элементов сразу:
d.extend([4,5,6]); d.extendleft([8,9])
# Развернуть очередь:
d.reverse()
# Переместить n элементов в начало:
d.rotate(3)
# Из начала в конец:
d.rotate(-3)

#? Defaultdict. Словарь, в котором по новым ключам генерируются объекты по умолчанию

from collections import defaultdict
# Создание пустого defaultdict со
# структурой list по умолчанию:
d = defaultdict(list)
# Можно сразу добавить значение в список
# по новому ключу:
d['new_key'].append(123)
# Обращение к несуществующему ключу
# приводит к добавлению ключа:
print(d['another_key'])
# []
print(d)
# defaultdict(<class 'list'>, {'new_key':
# [123], 'another_key': []})

#? Counter. Счётчик элементов в итерируемом объекте

from collections import Counter
# Создать счётчики из списка:
cars_moscow = ['black', 'black', 'white', 'black', 'black', 'white', 'yellow', 'yellow', 'yellow']
cars_spb = ['red', 'black', 'black', 'white', 'white', 'yellow', 'yellow', 'red', 'white']

counter_moscow = Counter(cars_moscow)
counter_spb = Counter(cars_spb)

print(counter_moscow)  ---> Counter({'black': 4, 'yellow': 3, 'white': 2})
print(counter_spb) ---> Counter({'white': 3, 'red': 2, 'black': 2, 'yellow': 2})

Сложение и вычитание
print(counter_moscow + counter_spb) ---> Counter({'black': 6, 'white': 5, 'yellow': 5, 'red': 2})

#* Чтобы узнать разницу между объектами Counter, необходимо воспользоваться функцией subtract.
#* Функция subtract модифицирует исходный счётчик.
    
counter_moscow.subtract(counter_spb)
print(counter_moscow) --->  Counter({'black': 2, 'yellow': 1, 'white': -1, 'red': -2}) 

#* Чтобы получить список всех элементов, которые содержатся в Counter, используется функция elements().
#* Элементы возвращаются в порядке появления уникальных элементов. 

print(*counter_moscow.elements()) ---> black black black black white white yellow yellow yellow

#* Чтобы получить список уникальных элементов, достаточно воспользоваться функцией list():
     
print(list(counter_moscow)) ---> ['black', 'white', 'yellow']


#* С помощью функции dict() можно превратить Counter в обычный словарь:

print(dict(counter_moscow)) ---> {'black': 4, 'white': 2, 'yellow': 3}
    
#* Функция most_common() позволяет получить список из кортежей элементов в порядке убывания
#* их встречаемости:

print(counter_moscow.most_common()) ---> [('black', 4), ('yellow', 3), ('white', 2)]

#* В неё можно передать значение, которое задаёт число первых наиболее частых элементов, например, 2:

print(counter_moscow.most_common(2)) ---> [('black', 4), ('yellow', 3)]

#* Наконец, функция clear() позволяет полностью обнулить счётчик:
    
counter_moscow.clear()
print(counter_moscow) --->  Counter()

#todo Модуль NumPy
#? Типы данных в NumPy
import numpy as np

# 1 байт — 8 бит
#* Целочисленные:
int8, int16, int32, int64
#* Целочисленные неотрицательные:
uint8, uint16, uint32, uint64
#* С плавающей точкой:
float16, float32, float64, float128
#* Справка о типе данных:
np.iinfo(<целый тип данных>)
np.finfo(<тип с плавающей точкой>)

print(np.iinfo(np.int8))
min = -128
max = 127

#* Строковые и булевые NumPy-типы:
np.str_, np.bool_

#? МАССИВЫ

#* Массив — это структура данных, в которой:
#*1. Элементы хранятся в указанном порядке.
#*2. Каждый элемент можно получить по индексу за одинаковое время.
#*3. Все элементы приведены к одному и тому же типу данных.
#*4. Максимальное число элементов и объём выделенной памяти заданы заранее.

#! Массив из чисел без и с типом данных:
arr = np.array([14, 23, 56])
arr = np.array([14, 23], dtype=np.int8)
#! Массив из нулей заданной формы:
arr = np.zeros(10)
arr = np.zeros((3, 4), dtype=np.int32)
#! Изменение формы массива:
arr.shape = (2,4) # Меняется форма arr
arr.reshape(<форма>) # Возвращается новый
arrT = arr.transpose() # Строки ↔ столбцы
#! Размерность, форма, число эл-ов:
arr.ndim; arr.shape; arr.size
#! Индексация и срезы в многомерном массиве:
nd_arr[1][4] = nd_arr[1, 4]
nd_arr[:, 2]
nd_arr[:3, 2:4]
#! Заполнить пропущенные значения нулями:
arr[np.isnan(arr)] = 0

# todo Задача:
import numpy as np


mystery = np.array([[-13586,  15203,  28445, -27117,  -1781, -17182, -18049],
       [ 25936, -30968,  -1297,  -4593,   6451,  15790,   7181],
       [ 13348,  28049,  28655,  -6012,  21762,  25397,   8225],
       [ 13240,   7994,  32592,  20149,  13754,  11795,   -564],
       [-21725,  -8681,  30305,  22260, -17918,  12578,  29943],
       [-16841, -25392, -17278,  11740,   5916,    -47, -32037]],
      dtype=np.int16)


#*1.В переменную elem_5_3 сохраните элемент из 5 строки и 3 столбца
elem_5_3=mystery[4,2]
#*2.В переменную last сохраните элемент из последней строки последнего столбца
last=mystery[-1,-1]
#*3.В переменную line_4 сохраните строку 4
line_4=mystery[3]
#*4.В переменную col_2 сохраните предпоследний столбец
col_2=mystery[:,-2]
#*5.Из строк 2-4 (включительно) получите столбцы 3-5 (включительно). Результат сохраните в переменную part
part=mystery[1:4,2:5]
#*6.Сохраните в переменную rev последний столбец в обратном порядке
rev = mystery[::-1, -1]
#*7.Сохраните в переменную trans транспонированный массив
trans=mystery.transpose()

#todo Задача:

import numpy as np


mystery = np.array([ 12279., -26024.,  28745.,  np.nan,  31244.,  -2365.,  -6974.,
        -9212., np.nan, -17722.,  16132.,  25933.,  np.nan, -16431.,
        29810.], dtype=np.float32)

#*Получите булевый массив nans_index с информацией о np.nan в массиве mystery: True - значение пропущено, 
#* False - значение не пропущено.
nans_index=np.isnan(mystery)
#*В переменную `n_nan сохраните число пропущенных значений
n_nan = len(mystery[nans_index])
#*Скопируйте массив mystery в массив mystery_new. Заполните пропущенные значения в массиве
#* mystery_new нулями
mystery_new=mystery
mystery_new[np.isnan(mystery_new)]=0
#*Поменяйте тип данных в массиве mystery на int32 и сохраните в переменную mystery_int
mystery_int = np.int32(mystery)
#*Отсортируйте значения в массиве по возрастанию и сохраните результат в переменную arra
array=np.sort(mystery)
#*Сохраните в массив table двухмерный массив, полученный из массива array. В нём должно быть 5 строк и 
#* 3 столбца. Причём порядок заполнения должен быть по столбцам!
table=array.reshape((5,3), order='F')
#*Сохраните в переменную col средний столбец из table
col=table[:,1]

#? ОПЕРАЦИИ С ВЕКТОРАМИ

#*В программировании вектором называют одномерный проиндексированный набор данных,
#* другими словами — одномерный массив.
#*С векторами в NumPy можно производить арифметические операции: складывать, вычитать,
#*умножать друг на друга, возводить один вектор в степень другого и т. д.
#*При сложении двух векторов первым элементом нового вектора будет сумма первых элементов
#*исходных векторов, вторым — сумма вторых элементов и т. д.

a = [3, 4, 2]
b = [12, 5, 8]
#! Векторы из диапазона чисел:
np.arange(<от>, <до>, <шаг>, dtype=<тип>)
np.linspace(<от>, <до>, <число>, dtype)
#! Арифметика:
a + b; a - b; a * b; a * 3; ...
#! Линейная алгебра:
np.linalg.norm(a) # Длина
np.linalg.norm(a-b) # Расстояние
np.dot(a, b) # Скалярное произведение
#! Сортировка:
np.sort(a) # Возвращает новый вектор
a.sort() # Изменяется исходный вектор
#! Статистика:
np.min(a) # Минимальное значение
np.max(a) # Максимальное значение
np.mean(a) # Среднее значение
np.sum(a) # Сумма значений

#todo Задача
#* Векторы в геометрии называются сонаправленными, если они коллинеарны и их направления совпадают.
#*Отметим, что прямые, на которых лежат сонаправленные вектора, всегда по определению являются параллельными.
#*Поэтому есть несколько математических способов определить сонаправленность векторов. Один из них: 
#*сумма длин сонаправленных векторов должна быть равной длине суммы двух векторов.
#*С помощью этого критерия среди векторов a, b и c (которые приведены в файле выше) найдите пару сонаправленных векторов.

import numpy as np

a = np.array([23, 34, 27])
b = np.array([-54,   1,  46])
c = np.array([46, 68, 54])

a_length = np.linalg.norm(a)
b_length = np.linalg.norm(b)
c_length = np.linalg.norm(c)

a_b=a_length+b_length
b_c=b_length +c_length
a_c=a_length+c_length

o=np.linalg.norm(a+b)
p=np.linalg.norm(b+c)
i=np.linalg.norm(a+c)

print(a_b==o) ---> False
print(b_c==p) ---> False
print(a_c==i) ---> True

#todo Задача
#* Найдите пару векторов, расстояние между которыми больше 100.

import numpy as np

a = np.array([23, 34, 27])
b = np.array([-54,   1,  46])
c = np.array([46, 68, 54])

o=np.linalg.norm(a-b)
p=np.linalg.norm(b-c)
i=np.linalg.norm(a-c)

print(o) ---> 85.901105930017
print(p) ---> 120.6358155772986
print(i) ---> 49.13247398615299

#? СЛУЧАЙНЫЕ ЧИСЛА

#*Случайное число — это число, которое возникает в результате случайного процесса.

#! Все функции из подмодуля np.random
#! Задать seed генерации случайных чисел:
seed(121223) # Аргумент — uint32
#! Случайные float от 0 до 1:
rand() # 1 число
rand(10) # 10 чисел
rand(12, 5) # 12 чисел 5 строк и 5 столбцов 
#! Эквивалентно:
sample((12, 5)) # Форма — кортеж
#! Float из диапазона:
uniform(<от>, <до>, size=<форма>)
#! Int из диапазона:
randint(<от>, <до>, size=<форма>)
#! Выборки:
shuffle(arr) # Перемешать тот же массив
permutation(arr) # Получить перемешанный
#! Выбрать часть объектов из массива:
choice(<массив или число>, size=<форма>,
replace=<Возможен повтор элементов?>)


#todo Задача
import numpy as np

#* Задайте seed = 2021.
np.random.seed(2021)
#*В simple сохраните случайное число в диапазоне от 0 до 1
simple=np.random.rand()
#*Сгенерируйте 120 чисел в диапазоне от -150 до 2021, сохраните их в переменную randoms
randoms=np.random.uniform(-150,2021, size=120)
#*Получите массив из случайных целых чисел от 1 до 100 (включительно) из 3 строк
#*и 2 столбцов. Сохраните результат в table
table=np.random.randint(1,101,size=(3,2))
#*В переменную even сохраните четные числа от 2 до 16 (включительно)
even=np.arange(2,18,2)
#*Скопируйте even в переменную mix. Перемешайте числа в mix так, чтобы массив изменился
mix=np.random.permutation(even)
#*Получите из even 3 числа без повторений. Сохраните их в переменную select
select=np.random.choice(even, size=3, replace=False)
#*Получите переменную triplet, которая должна содержать перемешанные значения из
#* массива select (сам select измениться не должен)
triplet=np.random.permutation(select)        

#todo Задача
#*Напишите функцию get_chess, которая принимает на вход длину стороны квадрата a и возвращает
#*двумерный массив формы (a, a), заполненный 0 и 1 в шахматном порядке. В левом верхнем
#*углу всегда должен быть ноль.
#*Примечание: воспользуйтесь функцией zeros из библиотеки numpy, а затем с
#*помощью срезов без циклов задайте необходимым элементам значение 1.
#*Напоминание: в Python для получения каждого второго элемента используется срез [::2]. 
#*Подумайте, как грамотно применить этот принцип к двумерному массиву.

import numpy as np

def get_chess(a):
    zeros_2d = np.zeros((a,a), dtype=np.float32)
    zeros_2d[1::2, ::2] = 1
    zeros_2d[::2, 1::2] = 1
    
 
    return  zeros_2d
    
     
print(get_chess(a = 5))